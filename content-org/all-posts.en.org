#+STARTUP: overview
#+HUGO_BASE_DIR: ../
#+HUGO_SECTION: en/posts
#+AUTHOR:
#+HUGO_CUSTOM_FRONT_MATTER: :author "<a href='https://k4i.top' class='theme-link'>k4i</a>"
#+LATEX_COMPILER: xelatex
#+LATEX_CLASS: elegantpaper

* DONE About
  CLOSED: [2021-11-23 Tue 16:16]
:PROPERTIES:
:EXPORT_HUGO_SECTION: en/
:EXPORT_HUGO_BUNDLE: about
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2021-11-23 Tue 14:18]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "About K4i"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :type "about"
:END:

[[../static/images/about/the-matrix-has-you.gif]]

** :triangular_flag_on_post: This Site

Generated using [[https://gohugo.io/][Hugo]], source code here: [[https://github.com/sky-bro/blog-src][blog-src]], and the theme is forked ([[https://github.com/sky-bro/hugo-theme-zzo][my fork]]) from: [[https://github.com/zzossig/hugo-theme-zzo][hugo-theme-zzo]].

BTW, instead of writing ~.md~ files, I keep all my blogs in ~.org~ files (stored inside [[https://github.com/sky-bro/blog-src/tree/master/content-org][blog-src/content-org]]), and export them to ~.md~ files with [[https://ox-hugo.scripter.co/][ox-hugo]].

** :sunrise: Daily Life

   - [[http://www.hit.edu.cn/][@HIT]]
   - C/C++, Golang, Python, ASM
   - Arch, Emacs, VSCode
   - CTF, ACM

** :love_letter: Contact Me

   - Email: [[mailto:sky_io@outlook.com][sky_io@outlook.com]]
   - WeChat: sky_bro
   - Facebook: [[https://www.facebook.com/profile.php?id=100005027239118][Kaiyu Shi]]
   - Twitter: [[https://twitter.com/KaiyuShi][KaiyuShi]]
   - GPG Pub: [[https://keybase.io/skybro/pgp_keys.asc][Kyle.asc]] (Key ID: F4CD0E4A366165D162E6B6CE7D36AE6055B060A6)
   - keybase: [[https://keybase.io/skybro][skybro]]

** :chicken: My Friends

[[https://thesong96.github.io/][TheSong]], [[https://lurenxiao1998.github.io/][路人枭]], [[https://pullp.github.io][wxk]]

** COMMENT :musical_score: Listening recently

#+html: <a href="https://open.spotify.com/user/22sit26j5lamlvm3sgikxwuoq"> <img src="https://spotify-readme-ky13.vercel.app/api/spotify" /> </a>

* DONE Writing Guide (org + ox-hugo)                        :@notes:hugo:org:
  CLOSED: [2021-12-05 Sun 20:58]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: writing-guide--org-plus-ox-hugo
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2021-11-22 Mon 20:23]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/org-mode-unicorn.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "New writing/bloging guide, Now I blog in org mode!"
:END:

I've recently switched to [[https://orgmode.org/][org mode]], now I write all my blogs in org mode ([[https://github.com/sky-bro/blog-src/blob/master/content-org/][blog-src/content-org/]]), and export them to ~.md~ files ([[https://github.com/sky-bro/blog-src/blob/master/content/][blog-src/content/]]) with ox-hugo.

So instead of editing ~.md~ files under ~content~ folder, now I write ~.org~ files stored under ~content-org~ folder.

** Create new post

Invoking org-capture-templates function, and choose hugo post template, as shown in Figure [[fig:org-capture-template-ox-hugo]]

#+CAPTION: creating new post with org-capture-template
#+NAME: fig:org-capture-template-ox-hugo
[[../static/images/posts/Writing-Guide-Org/org-capture-template-ox-hugo.gif]]

** Front matter

As in [[https://ox-hugo.scripter.co/doc/custom-front-matter/][ox-hugo: Custom Front-matter Parameters]], hugo front matters can be added like below:

#+begin_src org
  :PROPERTIES:
  :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :key1 value1 :key2 value2
  :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :key3 value3
  :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :key4 value4
  :END:
#+end_src

** Code

Inline code with '\equal' or '\tilde': ==echo 123==, ~~echo 456~~

Code block with

#+begin_src org
  ,#+begin_src c
    int main() {
      return 0
    }
  ,#+end_src
#+end_src

** Images

Store all the images under =$HUGO_BASE_DIR/static/= folder (except some generated images), so just include them using relative path from the org file.

You can add caption and name (for referencing purpose: as in figure [[fig:gopher]]) to an image.

#+CAPTION: Gogpher
#+NAME: fig:gopher
#+ATTR_HTML: :width 30%
[[../static/images/icons/gopher001.png]]

#+begin_src org
  ,#+CAPTION: Gogpher
  ,#+NAME: fig:gopher
  ,#+ATTR_HTML: :width 30%
  [[../static/images/icons/gopher001.png]]
#+end_src

** Math Support (with MathJax)

We need to have MathJax library in our front matter.

#+begin_src org
  :PROPERTIES:
  :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
  :END:
#+end_src

Inline formulas with =\$..\$=. This is inline math: $x^2 + y^2 = z^2 \frac{1}{2}$.

Displayed equations with =\$\$..\$\$= or $\LaTeX$ encironments. This is displayed math:

The code:

#+begin_src tex
  \begin{equation}\label{eq:1}
    \begin{split}
      a &= b+c-d\\
        &\quad +e-f\\
        &= g+h\\
        &= i
    \end{split}
  \end{equation}
#+end_src

will be rendered as:

\begin{equation}\label{eq:1}
  \begin{split}
    a &= b+c-d\\
      &\quad +e-f\\
      &= g+h\\
      &= i
  \end{split}
\end{equation}

{{< alert theme="warning" >}}
It seems that zzo theme does not support math equation referencing and numbering yet?
{{< /alert >}}

** Diagrams

*** Plantuml

use plantuml[fn:plantuml] to draw...

#+begin_src plantuml :file "../static/images/posts/Writing-Guide-Org/first.svg"
  title Authentication Sequence

  Alice->Bob: Authentication Request
  note right of Bob: Bob thinks about it
  Bob->Alice: Authentication Response
#+end_src

** Presentation

** Shortcodes

# https://github.com/kaushalmodi/ox-hugo/issues/126
#+begin_quote
zoo-docs[fn:zzo-docs] on short codes
#+end_quote

to use shortcodes as you do in markdown, put it after =#+html:=. Like this:


#+begin_src org
  ,#+html: {{</* gallery dir="/image_dir/" /*/>}}
#+end_src

*** Alert

You can have alert like this:

#+begin_src org
  ,#+html: {{</* alert theme="info" dir="ltr" */>}}
  theme could be one of: success, info, warning, danger
  ,#+html: {{</* /alert */>}}
#+end_src

#+html: {{< alert theme="success" >}}
this is a success.
#+html: {{< /alert >}}

#+html: {{< alert theme="info" >}}
this is a info.
#+html: {{< /alert >}}

#+html: {{< alert theme="warning" >}}
this is a warning.
#+html: {{< /alert >}}

#+html: {{< alert theme="danger" >}}
this is a danger.
#+html: {{< /alert >}}

*** Notice

#+begin_src org
  #+html: {{</* notice success "This is a success type of notice" */>}}
  notice could be success, info, warning, error.
  #+html: {{</* /notice */>}}
#+end_src

#+html: {{< notice success "This is a success type of notice" >}}
success notice.
#+html: {{< /notice >}}

#+html: {{< notice info "This is a info type of notice" >}}
info notice.
#+html: {{< /notice >}}

#+html: {{< notice warning "This is a warning type of notice" >}}
warning notice.
#+html: {{< /notice >}}

#+html: {{< notice error "This is a error type of notice" >}}
error notice.
#+html: {{< /notice >}}

*** Simple box

#+begin_src org
  #+html: {{</* box */>}}
  Plain text
  #+html: {{</* /box */>}}
#+end_src

#+html: {{< box >}}
Plain text
#+html: {{< /box >}}

*** Code in multiple language

#+begin_src org
  #+html: {{</* codes java javascript */>}}
    #+html: {{</* code */>}}
    ,#+begin_src java
      System.out.Println("Hello World!");
    ,#+end_src
    #+html: {{</* /code */>}}
    #+html: {{</* code */>}}
    ,#+begin_src javascript
      console.log('Hello World!');
    ,#+end_src
    #+html: {{</* /code */>}}
  #+html: {{</* /codes */>}}
#+end_src

#+html: {{< codes java javascript >}}
  #+html: {{< code >}}
  #+begin_src java
    System.out.Println("Hello World!");
  #+end_src
  #+html: {{< /code >}}
  #+html: {{< code >}}
  #+begin_src javascript
    console.log('Hello World!');
  #+end_src
  #+html: {{< /code >}}
#+html: {{< /codes >}}

*** Tab

#+begin_src org
  #+html: {{</* tabs Windows MacOS Ubuntu */>}}
    #+html: {{</* tab */>}}

    ,*** Windows section

    ,#+begin_src javascript
      console.log('Hello World!');
    ,#+end_src

    #+html: {{</* /tab */>}}
    #+html: {{</* tab */>}}

    ,*** MacOS section

    Hello world!
    #+html: {{</* /tab */>}}
    #+html: {{</* tab */>}}

    ,*** Ubuntu section

    Great!
    #+html: {{</* /tab */>}}
  #+html: {{</* /tabs */>}}
#+end_src

#+html: {{< tabs Windows MacOS Ubuntu >}}
  #+html: {{< tab >}}

  *** Windows section

  #+begin_src javascript
    console.log('Hello World!');
  #+end_src

  #+html: {{< /tab >}}
  #+html: {{< tab >}}

  *** MacOS section

  Hello world!
  #+html: {{< /tab >}}
  #+html: {{< tab >}}

  *** Ubuntu section

  Great!
  #+html: {{< /tab >}}
#+html: {{< /tabs >}}

*** Expand

#+begin_src org
  #+html: {{</* expand "Expand me" */>}}
  Some Markdown Contents
  #+html: {{</* /expand */>}}
#+end_src

#+html: {{< expand "Expand me" >}}
Some Markdown Contents
#+begin_src go
  package main

  import "fmt"

  func main() {
    fmt.Println("hello sky!")
  }
#+end_src
#+html: {{< /expand >}}

*** video

#+html: {{< youtube 2liXzaIIyuE >}}

** References

You can refer to something in the footnote like ox-hugo[fn:ox-hugo].

* DONE Org Notes                                                 :@notes:org:
  CLOSED: [2021-12-06 Mon 21:37]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: org-notes
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2021-11-22 Mon 10:50]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/org-mode-unicorn.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "My Notes on org writing."
:END:

** Basic Editing
*** Comments

+ /*C-c ;*/ :: toggle comment of an entry

#+BEGIN_COMMENT
this is comment line 01,
this is comment line 02.
#+END_COMMENT

# comment a line / line comment

*** Font types

#+begin_src org
  + /italic/
  + *bold*
  + _underlined_
  + =verbatim=
  + ~code~
  + +strike-through+
#+end_src

will be rendered as:

+ /italic/
+ *bold*
+ _underlined_
+ =verbatim=
+ ~code~
+ +strike through+

*** Org Entities

for entering special characters, we can use org entities:

https://stackoverflow.com/questions/16443386/how-to-escape-double-quote/31207746#31207746

#+begin_src org
  =\equal=
#+end_src

** Headings

#+begin_src org
  ,* H1
  ,** H2
  ,*** H3
  ,**** H4
#+end_src

+ ~C-RET~: new heading
+ ~M-RET~: new heading by spliting current heading
+ ~C-S-RET~: new heading, but with TODO
+ ~M-S-RET~: new heading by spliting current heading, but with TODO
+ ~M-LEFT/RIGHT~: Promote/Demote current subtree
+ ~M-UP/DOWN~: Move/swap subtree up/down

** Code

Offers two types of source code:

1. code block
2. inline code

org-entities-help function helps you insert some code.

*** inline

#+begin_src org
  src_c++[:exports code]{ typedef long long ll; }
  src_shell[:exports code]{ echo -e "test" }
#+end_src

src_c++[:exports code]{ typedef long long ll; }
src_shell[:exports code]{ echo -e "test" }

*** code block

source code blocks are one of many Org block types.

#+begin_src org
  ,#+BEGIN_SRC cpp
    #include <iostream>
    using namespace std;
    int main() {
      cout << "123\n";
      return 0;
    }
  ,#+END_SRC
#+end_src

#+BEGIN_SRC cpp
  #include <iostream>
  using namespace std;
  int main() {
    cout << "123\n";
    return 0;
  }
#+END_SRC

** List

+ M-RET :: new item at current level
+ M-S-RET :: new item with a checkbox
+ M-UP/DOWN :: move item up/down, including subitems
+ M-S-UP/DOWN :: move item up/down
+ M-LEFT/RIGHT :: decrease/increase indentation of item
+ M-S-LEFT/RIGHT :: decrease/increase indentation of item, including subitems
+ C-c C-c :: toggle checkbox
+ C-c - :: Cycle through itemize/enumerate bullets

** Table

+ /*|Name|Age C-c RET*/ create table with headers
  | NAME | Age |
  |------+-----|
  | sky  |  22 |
  | k4i  |  23 |
+ /*RET*/ go to next row
+ /*S-UP/DOWN/LEFT/RIGHT*/ swap between cells
+ /*M-UP/DOWN/LEFT/RIGHT*/ swap between rows/columns
+ /*M-S-UP/DOWN/LEFT/RIGHT*/ insert/delete row/column
+ /*C-c -*/ insert horizontal line below
+ /*C-c RET*/ insert horizontal line below, move to next row
+ /*C-c ^*/ sort column

** Footnote

for more information on footnote, please refer to the official org site[fn:orgmode].

*** footnote types:

+ named footnote :: fn:NAME
+ anonymous, inline footnote :: fn:: inline definition, fn:NAME: inline definition

*** example

 #+begin_src org
   The Org homepage[fn:1] now looks a lot better than it used to.
   ...
   [fn:1] The link is: https://orgmode.org
 #+end_src

** hyperlinks
+ formats
  + =[[link][description]]=
  + =[[link]]=
  + [[https://k4i.top/][k4i's home!]]
+ link types
  + internal links
  + external links
+ shortcuts
  + /*C-c C-l*/ :: insert/delete link
  + /*C-c C-o*/ :: open link

** todos [1/2]

*** DONE subtask 01
    CLOSED: [2021-10-23 Sat 23:18]

    + /*M-S-RET*/ :: new todo item
    + /*C-c C-t*/ :: cycle through todo states

*** BUG subtask 02 [1/2]
    + [-] item 01
      + [ ] item 01.01
      + [X] item 01.02
    + [X] item 02

** Images

+ /*C-c C-x C-v*/ :: toggle images (org-toggle-inline-images)

** Exports

*** latex

latex config

#+BEGIN_SRC shell
tlmgr update elegantpaper
tlmgr install elegantpaper # [[https://github.com/ElegantLaTeX/ElegantPaper][elegantpaper]]
tlmgr uninstall elegantpaper
pip install pygments # dependency of [[https://github.com/gpoore/minted][minted]]
#+END_SRC

add this in your front matter

#+BEGIN_SRC org
  ,#+LATEX_COMPILER: xelatex
  ,#+LATEX_CLASS: elegantpaper
  ,#+OPTIONS: prop:t
#+END_SRC

*** fixed reference ids

Org will set random ids for internal links, sometimes we want them to be fixed.

There are two solutions, one is to seed the random number generater[fn:seed-random-generator].

#+begin_src elisp
  (defun seed-random-generator (_) (random "a fixed and unchanging string"))
  (add-hook 'org-export-before-processing-hook #'seed-random-generator)
#+end_src

And another way is to override the ~org-export-new-reference~[fn:org-export-new-reference] function:

#+begin_src elisp
  (defun org-export-deterministic-reference (references)
    (let ((new (length references)))
      (while (rassq new references) (setq new (+ new 1)))
      new))
  (advice-add #'org-export-new-reference :override #'org-export-deterministic-reference)
#+end_src

* DONE Golang Notes                                           :@notes:golang:
  CLOSED: [2021-11-25 Thu 00:30]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: golang-notes
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2021-11-21 Sun 23:56]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :image "/images/icons/gopher001.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "This is my notes on learning golang."
:END:

** Basics
*** Packages

    every go program is made up of packages, and it starts from: /package main/,
    /func main()/

    packages could be imported, and grouped together using parenthesis
    ("factored" import statements)

    #+begin_src go
      import "fmt"
      import "math"
    #+end_src

    same as:

    #+begin_src go
      import (
        "fmt"
        "math"
      )
    #+end_src

    Only capitalized names are exported, therefore after importing a package, you
    can only reference its exported names.

*** Basic Types

    #+begin_src go
      package main

      import (
        "fmt"
        "math/cmplx"
      )

      // bool

      // string

      // int int8 int16 int32 int 64
      // uint uint8 uint16 uint32 uint64 unitptr

      // bytes // alias for uint8

      // rune // alias for int32, represents a unicode code point

      // float32 float64

      // complex64 complex128

      var (
        ToBe   bool       = false
        MaxInt uint64     = 1<<64 - 1
        z      complex128 = cmplx.Sqrt(-5 + 12i)
      )

      func main() {
        fmt.Printf("Type: %T Value: %v\n", ToBe, ToBe)
        fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)
        fmt.Printf("Type: %T Value: %v\n", z, z)
      }
    #+end_src

    the int, uint, and uintptr types are usually 32 bits on 32-bit systems and 64
    bits on 64-bit systems.

*** Variables

Two ways to declare a variable:
+ /var/
  + with or without initializer (implicitly initialized with zero value)
  + package or function scope
+ ~:=~ short assignment statements
  + only function scope
  + must have initializers

With an explicit initializer, no need to provide the type of the variable.

Apart from variables, there are constants, which:
+ can be declared in package or function level
+ must have explicit initializers (also constants, value known at compile time)
+ cannot be reassigned after initialization.

Multiple /var/ or /const/ statements could be grouped together like /imports/.

#+begin_src go
  // with initializer
  var i, j int = 1, 2
  // omit type (type inference)
  var i, j = 1, 2
  // short variable declarations (also type inference)
  a := 3 // int
  b := 3.14 // float64
  c := 0.1 + 0.2i

  // constants
  const Pi = 3.14
  // numeric constants are high-precision values
  const (
    Big = 1 << 100    // 1 << 100
    Small = Big >> 99 // 2
  )
#+end_src

*** Functions

#+begin_src go
  // type comes after variable name.
  func add(x int, y int) int {
    return x + y;
  }

  // consecutive named function parameters share a type
  func add(x, y int) int {
    return x + y;
  }

  // function can return any number of results
  func swap(x, y string) (string, string) {
    return y, x
  }

  // naked return: a return without arguments, can harm readability in longer
  // functions
  func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return
  }
#+end_src

**** Methods

     Go has no classes, but you can define methods on types. A method is a
     function with a special /receiver/ argument.

     #+begin_src go
       package main

       import (
         "fmt"
         "math"
       )

       type Vertex struct {
         X, Y float64
       }

       func (v Vertex) Abs() float64 {
         return math.Sqrt(v.X*v.X + v.Y*v.Y)
       }

       func (v *Vertex) Scale(f float64) {
         v.X = v.X * f
         v.Y = v.Y * f
       }

       func main() {
         v := Vertex{3, 4}
         v.Scale(10)
         fmt.Println(v.Abs()) // 50
       }
     #+end_src

     **The method and its receiver type must be defined in the same package.**

     #+begin_src go
       type MyFloat float64 // define your own float64 type
     #+end_src

**** Pointer Receivers or Arguments

     Receiver is just another argument, it can be nil.

     If you wanna modify or not copying an argument, you should pass pointer
     types.

     In general, all methods on a given type should have either value or pointer
     receivers, but not a mixture of both.

*** Type conversions

    ~T(v)~ converts the value ~v~ to the type ~T~.

    #+begin_src go
      i := 42
      f := float64(i)
      u := uint(f)
    #+end_src

    **no implicit conversion in go**

** Control FLow
*** For

Go only has for loop, no while loop, each for loop has three basic
components:
+ init statement
+ condition statement
+ post statement (execute after each iteration)

no parentheses, but curly braces ~{}~ are always required.

#+begin_src go
  package main

  import "fmt"

  func main() {
    sum := 0
    for i := 0; i < 10; i++ {
      sum += i
    }
    fmt.Println(sum)
  }
#+end_src

any of the three components can be omitted, if you only have condition or
nothing left, semicolon can be omitted.

#+begin_src go
  sum := 0
  // just like while loop
  for sum < 1000 {
    sum++
  }

  for {
    // loop forever
  }
#+end_src

you can ~continue~ or ~break~ inside a loop

*** If

like ~for~ loops, no parentheses ~()~, but curly braces ~{}~ are required

can have init statement

#+begin_src go
  if i := 0; i != 0 {
    fmt.Println("what?")
  } else if i == 0 {
    fmt.Println("got 0")
  } else {
    fmt.Println("no way here")
  }
#+end_src

*** Switch

+ shorter way to write a sequence of ~if-else~ statements.
+ no break or default fallthrough in switch
+ cases do need not to be constants or integers.
+ also support init statements like ~if~ and ~for~.

#+begin_src go
  package main

  import (
    "fmt"
    "runtime"
  )

  func main() {
    fmt.Print("Go runs on ")
    switch os := runtime.GOOS; os {
    case "darwin":
      fmt.Println("OS X.")
    case "linux":
      fmt.Println("Linux.")
    default:
      // freebsd, openbsd,
      // plan9, windows...
      fmt.Printf("%s.\n", os)
    }
  }
#+end_src

+ you can use ~fallthrough~ keyword to fallthrough
+ mutiple statements in a single case:
+ omit condition is the same as ~switch true~ (clean way to write long
  if-then-else chains)

#+begin_src go
  package main

  import (
    "fmt"
    "time"
  )

  func main() {
    t := time.Now()

    // same as: switch true
    switch {
    // default will always be last evaluated
    default:
      fmt.Println("default")
    case t.Hour() < 12:
      fmt.Println("morning")
    case t.Hour() < 17, true: // like useing '||', match any
      fmt.Println("afternoon")
      fallthrough
    case false:
      // even condition is false, fallthrough do fallthrough here
      fmt.Println("Are you ok?")
      // cannot put fallthrough in the last case or default
      // fallthrough
    }
  }
#+end_src

*** Defer

    a ~defer~ statement defers the execution of a function until the surrounding
    function returns.

    arguments evaluated immediately, but function call is not executed until the
    surrounding function returns.

    defered function calls are pushed onto a stack, so executed in last-in-first-outo order

    #+begin_src go
      package main

      import "fmt"

      func main() {
        fmt.Println("counting")

        for i := 0; i < 10; i++ {
          defer fmt.Println(i)
        }

        fmt.Println("done")
      }
    #+end_src

** Advanced types

*** Pointers

   A pointer holds the memory address of a value.

   Go has no pointer arithmetic.

   #+begin_src go
     var p *int
     i := 42
     p = &i // referencing
     fmt.Println(*p) // dereferencing
   #+end_src

*** Structs

    can be defined inside functions

    access struct fileds using a dot

    struct fields can also be accessed through a struct pointer, without explicit
    dereferencing.

    #+begin_src go
      package main

      import "fmt"

      func main() {
        type Vertex struct {
          X int
          Y int
        }
        v := Vertex{1, 2}
        p := &v // pointer to a struct
        v.X = 4
        (*p).Y = 6 // dereference the struct first - cumbersum
        p.Y = 5    // without explicit dereference
        fmt.Println(v)
      }
    #+end_src

    struct literal

    #+begin_src go
      package main

      import "fmt"

      type Vertex struct {
        X, Y int
      }

      func main() {
        var (
          v1 = Vertex{1, 2}  // {1, 2}, has type Vertex
          v2 = Vertex{Y: 1}  // {0, 1}
          v3 = Vertex{}      // {0, 0}
          p  = &Vertex{3, 4} // has type *Vertex
        )

        // {1 2} {0 1} {0 0} &{3 4}
        fmt.Println(v1, v2, v3, p)
      }
    #+end_src

*** Arrays

    ~[n]T~ is an array of ~n~ values of type ~T~.

    Arrays cannot be resized

    #+begin_src go
      package main

      import "fmt"

      func main() {
        // [1 2 0]
        fmt.Println([3]int{1, 2})
      }
    #+end_src

*** Slices

    A slice is a dynamically-sezed, flexible view into the elements of an array.

    ~[n]T~ is an array of type T and length n.

    ~[]T~ is a slice of type T, it does not store any data, it just describes a
    section of the underlying array.

    #+begin_src go
      package main

      import "fmt"

      func main() {
        // array literal
        v := [5]int{1, 2}
        // slice literal
        // v := []int{1, 2, 0, 0, 0}
        v1 := v[1:3]
        fmt.Println(cap(v))  // 5
        fmt.Println(cap(v1)) // 4, counting from first element in the slice
        fmt.Println(len(v1)) // 2
        fmt.Println(v1)      // [2 0]
      }
    #+end_src

    When slicing, you may omit the high or low bounds to use their defaults
    instead (/0/ for low, /len/ for high)

    making a slice

    #+begin_src go
      a := make([]int, 5)    // len(a)=5, cap(a)=5
      b := make([]int, 0, 5) // len(b)=0, cap(b)=5
      b = b[:cap(b)]         // len(b)=5, cap(b)=5
      b = b[1:]              // len(b)=4, cap(b)=4
    #+end_src

    appending to a slice

    #+begin_src go
      func printSlice(s []int) {
        fmt.Printf("len=%d, cap=%d, addr=%p, %v\n", len(s), cap(s), &s, s)
      }

      func main() {
        var s []int
        printSlice(s) // len=0, cap=0
        s = append(s, 0)
        printSlice(s) // len=1, cap=1
        s = append(s, 1)
        printSlice(s) // len=2, cap=2
        s = append(s, 1)
        printSlice(s) // len=3, cap=4
        s = append(s, 1, 2, 3)
        printSlice(s) // len=6, cap=8
      }
    #+end_src

    if the backing array is too small to fit all the given values a bigger array
    will be allocated. The returned slice will point to the newly allocated
    array.

    range

    #+begin_src go
      package main

      import "fmt"

      var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

      func main() {
        // for i, _ := range pow
        // for i := range pow
        // for _, v := range pow
        for i, v := range pow {
          fmt.Printf("2**%d = %d\n", i, v)
        }
      }
    #+end_src

*** Maps

    #+begin_src go
      package main

      import "fmt"

      type Vertex struct {
        X, Y int
      }

      func main() {
        var v = map[int]Vertex{
          3: {1, 2},
        }
        // x := v[2]
        x, ok := v[2]
        // ok is false
        if !ok {
          fmt.Println("no v[2]")
          fmt.Printf("x is the zero value of Vertex, which is %v\n", x)
        }
        fmt.Println(v[3])
        // insert or update an element
        v[3] = Vertex{3, 4}
        // delete a key
        delete(v, 3)
      }
    #+end_src

*** Function Type

    Functions are values too, they can be used as funtion arguments and return
    values.

    #+begin_src go
      package main

      import "fmt"

      func f(fn func(int) string, x int) string {
        return fn(x)
      }

      func main() {

        myF := func(x int) string {
          return "xy"
        }

        fmt.Println(f(myF, 3))
      }
    #+end_src

    Receiver is actually the first argument of a method:

    #+begin_src go
      package main

      import (
        "fmt"
        "math"
      )

      type Vertex struct {
        X, Y float64
      }

      func (v Vertex) Abs() float64 {
        return math.Sqrt(v.X*v.X + v.Y*v.Y)
      }

      func (v *Vertex) Scale(f float64) {
        v.X = v.X * f
        v.Y = v.Y * f
      }

      func f(fn func(Vertex) float64, v *Vertex) {
        fmt.Println(fn(*v))
      }

      func f2(fn func(*Vertex) float64, v *Vertex) {
        fmt.Println(fn(v))
      }

      func main() {
        v := Vertex{3, 4}
        f(Vertex.Abs, &v)
        f2((*Vertex).Abs, &v)
        // these two are different function
        // receiver is actually the first argument of method
        fmt.Printf("%T\n", (*Vertex).Scale)
        fmt.Printf("%T\n", v.Scale)
      }
    #+end_src

    A closure is a function value that references variables from outside its
    body.

    #+begin_src go
      package main

      import "fmt"

      func adder() func(int) int {
        sum := 0
        return func(x int) int {
          sum += x
          return sum
        }
      }

      func main() {
        pos, neg := adder(), adder()
        for i := 0; i < 10; i++ {
          fmt.Println(
            pos(i),
            neg(-2*i),
          )
        }
      }
    #+end_src

*** Interfaces

    An interface type is a set of method signatures.

    An interface value is any type that has implemented those methods
    (implemented implicitly, no "implements" keyword).

    #+begin_src go
      package main

      import (
        "fmt"
        "math"
      )

      type Abser interface {
        Abs() float64
      }

      func main() {
        var a Abser
        f := MyFloat(-math.Sqrt2)
        v := Vertex{3, 4}

        a = f  // a MyFloat implements Abser
        a = &v // a *Vertex implements Abser

        // In the following line, v is a Vertex (not *Vertex)
        // and does NOT implement Abser.
        // a = v

        fmt.Println(a.Abs())
      }

      type MyFloat float64

      func (f MyFloat) Abs() float64 {
        if f < 0 {
          return float64(-f)
        }
        return float64(f)
      }

      type Vertex struct {
        X, Y float64
      }

      func (v *Vertex) Abs() float64 {
        return math.Sqrt(v.X*v.X + v.Y*v.Y)
      }
    #+end_src

    printing value and type of an interface is the same as printing its
    underlying value and type.

    #+begin_src go
      package main

      import "fmt"

      type I interface {
        M()
      }

      type T struct {
        S string
      }

      func (t *T) M() {
        if t == nil {
          fmt.Println("<nil>")
          return
        }
        fmt.Println(t.S)
      }

      func main() {
        var i I

        var t *T
        i = t
        describe(i)
        i.M()

        i = &T{"hello"}
        describe(i)
        i.M()
      }

      func describe(i I) {
        fmt.Printf("(%v, %T)\n", i, i)
      }
    #+end_src

    The interface that specifies zero methods is known as the empty interface.

    #+begin_src go
      package main

      import "fmt"

      func main() {
        var i interface{}
        describe(i)

        i = 42
        describe(i)

        i = "hello"
        describe(i)
      }

      func describe(i interface{}) {
        fmt.Printf("(%v, %T)\n", i, i)
      }
    #+end_src

**** Type assertions

     try converting an interface to its underlying value of type T: ~s := i.(T)~

     here ~T~ must implement methods of i.

     #+begin_src go
       package main

       import "fmt"

       func main() {
         var i interface{} = "hello"

         s := i.(string)
         fmt.Println(s)

         s, ok := i.(string)
         fmt.Println(s, ok)

         f, ok := i.(float64)
         fmt.Println(f, ok)

         f = i.(float64) // panic
         fmt.Println(f)
       }
     #+end_src

     #+begin_src go
       package main

       import "fmt"

       type Vertex struct {
         x, y int
       }

       // value of type *Vertex can also call method M()
       func (Vertex) M() {}

       func main() {
         var v Vertex

         var i interface {
           M()
         } = v

         // argument here must implement methods of the interface
         t, ok := i.(*Vertex)
         des(t) // *main.Vertex, <nil>
         chk(t, ok)

         t2, ok := i.(Vertex)
         des(t2) // main.Vertex, {0, 0}
         chk(t2, ok)
       }

       func des(v interface{}) {
         fmt.Printf("%T, %v\n", v, v)
       }

       func chk(t interface{}, ok bool) {
         if !ok {
           fmt.Println("type not correct, zero value returned:", t)
         } else {
           fmt.Println("type correct, value is:", t)
         }
       }
     #+end_src

**** type switches

     #+begin_src go
       package main

       import "fmt"

       func do(i interface{}) {
         switch v := i.(type) {
         case int:
           fmt.Printf("Twice %v is %v\n", v, v*2)
         case string:
           fmt.Printf("%q is %v bytes long\n", v, len(v))
         default:
           // here v has the same type as i
           fmt.Printf("I don't know about type %T!\n", v)
         }
       }

       func main() {
         do(21)
         do("hello")
         do(true)
       }
     #+end_src

** Zero values

   variables declared without an explicit initial value are given their zero
   value.

   + 0 for numeric types
   + false for the boolean type
   + "" (the empty string) for the strings
   + ~{<default field values>}~ for structs
   + nil for slice (len and cap of a nil slice is 0)
   + nil for maps
   + nil for interfaces
   + nil for pointers

** Common Interfaces

*** Error

    When ~fmt~ prints values, it looks for the error interface first:

    #+begin_src go
      type error interface {
        Error() string
      }
    #+end_src

    if the interface value is not ~<nil>~, the Error() method will be invoked by
    ~fmt~ to get the error string.

    #+begin_src go
      i, err := strconv.Atoi("42")
      if err != nil {
        fmt.Printf("couldn't convert number: %v\n", err)
        return
      }
      fmt.Println("Converted integer:", i)
    #+end_src

    Do not print the interface value in the Error() method directly, it will cause
    infinite loop.

    #+begin_src go
      type ErrNegativeSqrt float64

      func (e ErrNegativeSqrt) Error() string {
        // do not print e directly, infinite loop here
        // fmt.Println(e)
        return fmt.Sprintln("cannot Sqrt negative number: ", float64(e))
      }
    #+end_src

*** Reader

    the ~io.Reader~ interface has a ~Read~ method:

    #+begin_src go
      func (T) Read(b []byte) (n int, err error)
    #+end_src

    read populates the given byte slice with data and returns the number of bytes
    populated and an error value.

    it returns an ~io.EOF~ error when the stream ends.

    #+begin_src go
      package main

      import (
        "fmt"
        "io"
        "strings"
      )

      func main() {
        r := strings.NewReader("Hello, Reader!")

        b := make([]byte, 8)
        for {
          n, err := r.Read(b)
          fmt.Printf("n = %v err = %v b = %v\n", n, err, b)
          fmt.Printf("b[:n] = %q\n", b[:n])
          if err == io.EOF {
            break
          }
        }
      }
    #+end_src

*** Image

    ~image.Image~ defines the Image interface

    #+begin_src go
      type Image interface {
        ColorModel() color.Model
        Bounds() Rectangle
        At(x, y int) color.Color
      }
    #+end_src

** Goroutines

   a /goroutine/ is a lightweight thread managed by the Go runtime.

*** Channels

    By default, sends and receives block until the other side is ready. This
    allows goroutines to synchronize without explicit locks or condition
    variables.

    Channels aren't like files, you don't usually need to close them. Closing is
    only necessary when the receiver must be told there are no more values
    coming, such as to terminate a ~range~ loop.

    #+begin_src go
      package main

      import "fmt"

      func fib(n int, c chan int) {
        a, b := 0, 1
        for i := 0; i < n; i++ {
          c <- a
          a, b = b, a+b
        }
        close(c)
      }

      func main() {
        c := make(chan int)
        go fib(10, c)
        for x := range c {
          fmt.Println(x)
        }
        // "ok" is false if there are:
        // 1. no more values to receive
        // 2. and the channel is closed
        // x, ok := <- c
      }
    #+end_src

*** Select

    /select/ statement lets a goroutine wait on multiple communication
    operations.

    /select/ blocks until one of its cases can run (by adding a /default/ case,
    it won't block). It chooses one at random if multiple are ready.

    #+begin_src go
      package main

      import "fmt"

      func fibonacci(c, quit chan int) {
        x, y := 0, 1
        for {
          select {
          case c <- x:
            x, y = y, x+y
          case <-quit:
            fmt.Println("quit")
            return
          }
        }
      }

      func main() {
        c := make(chan int)
        quit := make(chan int)
        go func() {
          for i := 0; i < 10; i++ {
            fmt.Println(<-c)
          }
          quit <- 0
        }()
        fibonacci(c, quit)
      }
    #+end_src

*** Mutex

    /sync.Mutex/ provides two methods: ~Lock~ and ~Unlock~

    #+begin_src go
      // SafeCounter is safe to use concurrently.
      type SafeCounter struct {
        mu sync.Mutex
        v  map[string]int
      }

      func (c *SafeCounter) Value(key string) int {
        c.mu.Lock()
        // Lock so only one goroutine at a time can access the map c.v.
        defer c.mu.Unlock()
        return c.v[key]
      }
    #+end_src

** Practice

*** Sqrt

    #+begin_src go
      package main

      import "fmt"

      func Sqrt(x float64) (res float64) {
        res = 1.
        diff := 1.
        for diff > 1e-5 || diff < -1e-5 {
          diff = (res*res - x) / (2 * res)
          res -= diff
        }
        return
      }

      func main() {
        fmt.Println(Sqrt(4))
      }
    #+end_src

*** WordCount

    #+begin_src go
      package main

      import (
        "strings"

        "golang.org/x/tour/wc"
      )

      func WordCount(s string) (m map[string]int) {
        m = make(map[string]int)
        for _, x := range strings.Fields(s) {
          m[x]++
        }
        return m
      }

      func main() {
        wc.Test(WordCount)
      }
    #+end_src

*** Fibonacci closure

    #+begin_src go
      package main

      import "fmt"

      // fibonacci is a function that returns
      // a function that returns an int.
      func fibonacci() func() int {
        a, b := 0, 1
        return func() int {
          ret := a
          a, b = b, a + b
          return ret
        }
      }

      func main() {
        f := fibonacci()
        for i := 0; i < 10; i++ {
          fmt.Println(f())
        }
      }
    #+end_src

*** Sqrt with Error Handling

    #+begin_src go
      package main

      import (
        "fmt"
        "math"
      )

      type ErrNegativeSqrt float64

      func (e ErrNegativeSqrt) Error() string {
        // float64(e) here is important
        // fmt.Sprint(e) will cause infinite loop!
        return fmt.Sprint("cannot Sqrt negative number:", float64(e))
      }

      func Sqrt(x float64) (float64, error) {
        if x < 0 {
          return x, ErrNegativeSqrt(x)
        }
        return math.Sqrt(x), nil
      }

      func main() {
        fmt.Println(Sqrt(2))
        fmt.Println(Sqrt(-2))
      }
    #+end_src

*** rot13Reader

    #+begin_src go
      package main

      import (
        "io"
        "os"
        "strings"
      )

      type rot13Reader struct {
        r io.Reader
      }

      func (rot13reader rot13Reader) Read(b []byte) (int, error) {
        n, err := rot13reader.r.Read(b)
        if err != nil {
          return 0, io.EOF
        }
        for i := 0; i < n; i++ {
          switch c := b[i]; {
          case c >= 'A' && c <= 'Z':
            b[i] = 'A' + (b[i]-'A'+13)%26
          case c >= 'a' && c <= 'z':
            b[i] = 'a' + (b[i]-'a'+13)%26
          }
        }
        return n, nil
      }

      func main() {
        s := strings.NewReader("Lbh penpxrq gur pbqr!")
        r := rot13Reader{s}
        io.Copy(os.Stdout, &r)
      }
    #+end_src

*** Implement Image interface

    #+begin_src go
      package main

      import (
        "image"
        "image/color"

        "golang.org/x/tour/pic"
      )

      type Image struct {
        w, h int
      }

      func (img Image) ColorModel() color.Model {
        return color.RGBAModel
      }

      func (img Image) Bounds() image.Rectangle {
        return image.Rect(0, 0, img.w, img.h)
      }

      func (img Image) At(x, y int) color.Color {
        return color.RGBA{uint8(x + y), uint8(x + y), 255, 255}
      }

      func main() {
        m := Image{100, 100}
        pic.ShowImage(m)
      }
    #+end_src

*** Web Crawler

    #+begin_src go
      package main

      import (
        "fmt"
        "sync"
      )

      type Fetcher interface {
        // Fetch returns the body of URL and
        // a slice of URLs found on that page.
        Fetch(url string) (body string, urls []string, err error)
      }

      type url2Dep struct {
        mu sync.Mutex
        mp map[string]int
      }

      func (u *url2Dep) insertUrl(url string, dep int) {
        u.mu.Lock()
        defer u.mu.Unlock()
        u.mp[url] = dep
      }

      func (u *url2Dep) getDep(url string) (int, bool) {
        u.mu.Lock()
        defer u.mu.Unlock()
        dep, ok := u.mp[url]
        return dep, ok
      }

      // Crawl uses fetcher to recursively crawl
      // pages starting with url, to a maximum of depth.
      func Crawl(u *url2Dep, url string, depth int, fetcher Fetcher) {
        defer wg.Done()
        if depth <= 0 {
          return
        }
        if dep, ok := u.getDep(url); !ok || dep < depth {
          u.insertUrl(url, depth)
        } else {
          fmt.Printf("visited: %s\n", url)
          return
        }
        body, urls, err := fetcher.Fetch(url)
        if err != nil {
          fmt.Println(err)
          return
        }
        fmt.Printf("found: %s %q\n", url, body)
        for _, nextUrl := range urls {
          wg.Add(1)
          go Crawl(u, nextUrl, depth-1, fetcher)
        }
      }

      var wg sync.WaitGroup

      func main() {
        u := url2Dep{mp: make(map[string]int)}
        wg.Add(1)
        go Crawl(&u, "https://golang.org/", 4, fetcher)
        wg.Wait()
      }

      // fakeFetcher is Fetcher that returns canned results.
      type fakeFetcher map[string]*fakeResult

      type fakeResult struct {
        body string
        urls []string
      }

      func (f fakeFetcher) Fetch(url string) (string, []string, error) {
        if res, ok := f[url]; ok {
          return res.body, res.urls, nil
        }
        return "", nil, fmt.Errorf("not found: %s", url)
      }

      // fetcher is a populated fakeFetcher.
      var fetcher = fakeFetcher{
        "https://golang.org/": &fakeResult{
          "The Go Programming Language",
          []string{
            "https://golang.org/pkg/",
            "https://golang.org/cmd/",
          },
        },
        "https://golang.org/pkg/": &fakeResult{
          "Packages",
          []string{
            "https://golang.org/",
            "https://golang.org/cmd/",
            "https://golang.org/pkg/fmt/",
            "https://golang.org/pkg/os/",
          },
        },
        "https://golang.org/pkg/fmt/": &fakeResult{
          "Package fmt",
          []string{
            "https://golang.org/",
            "https://golang.org/pkg/",
          },
        },
        "https://golang.org/pkg/os/": &fakeResult{
          "Package os",
          []string{
            "https://golang.org/",
            "https://golang.org/pkg/",
          },
        },
      }
    #+end_src
* DONE Vim Notes                                          :@notes:vim:editor:
  CLOSED: [2021-12-06 Mon 20:56]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: vim-notes
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2021-12-06 Mon 20:24]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/vim-logo.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "my notes/cheatsheet on using vim."
:END:

** my simple config

my simple config can be found here: [[https://github.com/sky-bro/.dotfiles/blob/master/.vimrc][.dotfiles/.vimrc]]

** widows

- /*C-w s*/ :: horizontal split window
- /*C-w v*/ :: vertical split window
- /*C-w q*/ :: quit a window
- /*C-w h/j/k/l*/ :: move between windows
- /*C-w H/J/K/L*/ :: make current master window
- /*C-w +\slash-*/ :: inc/dec height, can prepend with a number
- /*C-w >/<*/ :: inc/dec width, can prepend with a number

** jump

- /*C-o*/ :: jump back
- /*C-i*/ :: jump forward

** Folding

- ~zc~: fold/close current tree
- ~zo~: unfold/open current tree
- ~za~: toggle fold

** Search and replace

https://vim.fandom.com/wiki/Search_and_replace
single buffer

- =/pattern=
- =?pattern=
- =:%s/old/new/g=
- =:%s/old/new/gc=

multiple files

** References

+ [[https://vim.rtorr.com/][Vim Cheat Sheet]]
+ [[../static/images/posts/vim-notes/vim-cheatsheet.svg][vi / vim graphical cheat sheet]]
* DONE Ranger Notes                                           :@notes:ranger:
  CLOSED: [2021-12-08 Wed 00:03]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: ranger-notes
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2021-12-07 Tue 19:16]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/ranger_logo.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "ranger is a terminal based file manager."
:END:

I am planing on totally changing to the terminal based file manager: ranger.

And this is my cheatsheet on using it, for more detailed guides you can go check the ranger official user guide[fn:ranger-official-user-guide].

** launch

I use ~$mod+Shift+Return~ to launch my ranger, and this keybinding is set in the i3 config file as below.

#+begin_src shell
  # ~/.config/i3/config
  bindsym $mod+Shift+Return exec cd "$(xcwd)" && exec st -e "ranger"
#+end_src

Here I also use xcwd[fn:xcwd] to get my current working directory, so I can launch ranger from that directory.

** Key bindings and hints

+ ~g~: navigation and tabs
+ ~r~: open with
+ ~y~: yank
+ ~d~: cut/delete
+ ~p~: paste
+ ~o~: sort
+ ~.~: filter_stack ??
+ ~z~: settings
+ ~u~: undo
+ ~M~: linemode
+ ~+, -, =~: rights
+ ~Alt+N~: switch(~Tab~), create tab

** configuration files

under =~/.config/ranger/= folder, there are 4 main configuration files:

+ ~rc.conf~: the main config, various key bindings and switches
+ ~rfile.conf~: how to open a file
+ ~scope.sh~: how to preview a file
+ ~commands.py~: implement various commands (functions), you can add your custom commands here.

** Bookmarks

+ ~m<key>~: bookmark current folder
+ ~'<key>~: go to a bookmark
+ ~um<key>~: remove a bookmark

** Select/Mark files

+ ~SPC~: mark current file
+ ~v~: invert selection (easy to select all)
+ ~V~: visual mode, to mark a range of files
+ ~:mark REGEX~, ~:unmark REGEX~: to mark/unmark with regex expression.
+ ~uv~, ~:unmark~: unmark all files

** Macros

+ ~%f~: the highlighted file
+ ~%d~: the path of the current directory
+ ~%s~: the selected files in the current directory
+ ~%t~: the tagged files in the current directory
+ ~%c~: the full pathes of the currently copied/cut files
+ ~%p~: the full pathes of selected files

** Rename, Create Files & Folders

+ ~cw~: to rename selected file or files (bulk rename, works great with ~:flat~)
+ ~:mkdir~: create directory
+ ~:touch~: create file

** TODO drag and drop

https://github.com/ranger/ranger/wiki/Drag-and-Drop

* DONE Terminal & Shell Setup (st & zsh)              :@notes:shell:terminal:
  CLOSED: [2021-12-09 Thu 00:09]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: terminal-and-shell-setup--st-and-zsh
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2021-12-08 Wed 17:07]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/terminal.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "show my terminal & shell setup."
:END:

My terminal emulator is st (simple terminal) from LukeSmith[fn:st-from-luke], and my shell is zsh (with ohmyzsh[fn:ohmyzsh]).

** Dependencies

+ dmenu
+ fzf[fn:fzf]
+ pywal[fn:pywal]

** ohmyzsh

#+begin_src shell
  # . start-proxy 1081 socks5h
  sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
#+end_src

Then config or restore[fn:dotfiles] your ~~/.zshrc~ file.

#+begin_src shell
  dotfiles checkout ~/.zshrc
#+end_src

** colors and themes

*** p10k

I use powerlevel10k[fn:p10k] as my zsh theme.

1. clone the repository:
   #+begin_src shell
     git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k
     # for chinese users, recommend:
     # git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k
   #+end_src
2. set ~ZSH_THEME="powerlevel10k/powerlevel10k"~ in ~~/.zshrc~.
3. configure with ~p10k~

*** Xresources and pywal

you can define your color scheme in ~~/.Xresources~ file, and load it with ~xrdb ~/.Xresources~.

Or you can let pywal generates and sets a colorscheme for you:

#+begin_src shell
  #!/bin/sh

  # We grab the wallpaper location from wal's cache so
  # that this works even when a directory is passed.
  image_path="${1:-"$(< "${HOME}/.cache/wal/wal")"}"

  # -n tells =wal= to skip setting the wallpaper.
  wal -n -i "$image_path"
  feh --no-fehbg --bg-fill "$image_path"
#+end_src

This is a script[fn:wal-feh] to set my wallpaper and color scheme from an image: ~wal-feh wallpaper.png~.

And I put ~exec --no-startup-id ~/bin/wal-feh~ in my ~~/.config/i3/config~ to autostart it.

** fzf

Install fzf, then put this in your ~~/.zshrc~:

#+begin_src shell
  source /usr/share/fzf/key-bindings.zsh
  source /usr/share/fzf/completion.zsh
#+end_src

** zsh-autosuggestions

Fish-like fast/unobtrusive autosuggestions for zsh.

1. clone the repository:

   #+begin_src shell
     git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
   #+end_src

2. add the plugin to the ~plugins~ list inside the ~~/.zshrc~ file.

   #+begin_src shell
     plugins=(
         # other plugins...
         zsh-autosuggestions
     )
   #+end_src

** keybindings

+ ~alt-l~: follow urls
+ ~alt-y~: copy urls
+ ~alt-o~: copy output of a command
+ ~alt-j/k/d/u~: scroll down/up/faster-down/faster-up
+ ~alt-c/v~: copy/paste
+ ~Ctrl+t~: list files+folders in current directory (e.g., type ~git add~, press ~Ctrl+t~, select a few files using ~Tab~, finally ~Enter~)
+ ~Ctrl+r~: search history commands
+ ~ESC+c~: fuzzy change directory

* DONE Clipboard Manager: CopyQ                            :@notes:clipboard:
  CLOSED: [2021-12-15 Wed 15:20]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: clipboard-manager-copyq
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2021-12-15 Wed 10:32]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/copyq-logo.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "CopyQ is a clipboard manager written in Qt/C++"
:END:

** Introduction

CopyQ[fn:copyq] is a clipboard manager with many features.

+ manages clipboard history
+ history in different tabs
+ Store text, HTML, images or any other custom formats
+ Support custom commands[fn:copyq-commands], like saving clipboard items to file
+ vi style navigation

** Basic Setup

+ Enable ~vi style navigation~ in ~Preferences -> General~
+ Enable ~Tab Tree~ and ~Show Item Count~ in ~Preferences -> Layout~
+ Custom shortcuts in ~Preferences -> Shortcuts~ or in ~File -> Commands/GlobalShortcuts (press F6 from main window)~

** Add Commands

You can get many useful commands from CopyQ-Commands[fn:copyq-commands], or you can create your own commands following the documentation.

To add a command to CopyQ:
+ copy the command code (starts with [Command] or [Commands] for multiple commands)
+ open CopyQ (~Ctrl-Alt-h~)
+ open command dialog (~F6~)
+ click "Paste Commands" button (~Ctrl-v~)
+ apply changes

Commands that I use:

+ [[https://github.com/hluk/copyq-commands/blob/master/Application/save-item-clipboard-to-file.ini][Save Item/Clipboard To a File]]: Opens dialog for saving selected item data to a file.
+ [[https://github.com/hluk/copyq-commands/blob/master/Automatic/image-tab.ini][Image Tab]]: Automatically store images copied to clipboard in a separate tab.

** Key Bindings

+ ~Ctrl-Alt-h~: open/close main window, show clipboard history (customized)
+ ~Ctrl-Alt-s~: save as (customized)
+ ~j/k~: next/previous item
+ ~Ctrl-h~: previous tab
+ ~l/Enter~: copy & paste item
+ ~Ctrl-c~: copy item
+ ~ESC/Ctrl-[~: close window

* DONE Fix boot problem after updating packages           :@debug:linux:boot:
CLOSED: [2022-01-12 Wed 13:02]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: fix-boot-problem-after-updating-packages
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2022-01-12 Wed 11:46]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/how-tough-am-i-i-do-sudo-pacman-syu-everyday.jpg"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "pacman -Syu broke my linux again!!"
:END:

** Introduction

Just the other day I updated all my packages through =yay -Syu= (like =pacman -Syu= but also updates aur packages).

And after a reboot, it entered a boot loop...

I believe this had happened to most arch users, and most of the time its just because we broke the dependencies of some packages after the upgrade.

So here's how I saved boot failure after =yay -Syu=.

#+html: {{< alert theme="info" dir="ltr" >}}
You'll need a bootable usb stick (preferable the one you use for installing the system).
#+html: {{< /alert >}}

** Manually boot from grub (optional)

follow this guide[fn:manually-boot-up-linux] to boot your linux from grub (generates log).

The grub command line can also be entered from your bootable usb drive.

#+begin_src shell
  ls # list partitions
  ls (hd1,gpt2)/ # see files in a partition
  set root=(hd1,gpt2) # your linux root partition
  linux /boot/vmlinuz-5.13-x86_64 ro root=/dev/nvme0n1p1
  initrd /boot/initramfs-5.13-x86_64.img
  boot
#+end_src

** chroot to your system

manjaro-chroot is provide in =manjaro-tools-base= package, and is already installed in your live system.

#+begin_src shell
  # mount root
  mount /dev/nvme0n1p2 /mnt
  # mount boot
  # mount /dev/xxx /mnt/boot
  # mount efi
  mount /dev/nvme0n1p1 /mnt/boot/efi/

  manjaro-chroot /mnt
#+end_src

** check your boot log

#+begin_src shell
  # -b: show boot log
  # -1: offset, last boot
  journalctl -b -1
#+end_src

** fix any problems

find any suspicious errors in the boot log, and search it on the web, see how to fix them.

for me, a package from aur was causing the problem, and I tried to fix it, but no luck.

So I just uninstalled it!

** reboot

success!

* DONE Manage My Dotfiles With Stow               :@workspace_setup:dotfiles:
CLOSED: [2022-01-20 Thu 15:33]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: manage-my-dotfiles-with-stow
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2022-01-19 Wed 17:40]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/dotfiles-logo-icon.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "manage dotfiles with stow."
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-01-20 Thu 15:33]
:END:

** Introduction

I used to manage my dotfiles[fn:dotfiles] with a bare git repository, its simple, but dotfiles are all over the place, it's hard for me to get a whole view of them.

So now I've switched to stow[fn:gnu-stow], which is a symlink manager to help you put all files you want in one place and symlink them to where they belong (it creates symlink for files in one folder to another folder).

** First Time Setup

So the first time we use stow to manage our dotfiles, we just need to follow these steps.

1. create dotfiles folder in your home directory (preferably)
2. move files to that folder
3. add =.stow-local-ignore= file ([[https://www.gnu.org/software/stow/manual/html_node/Types-And-Syntax-Of-Ignore-Lists.html][Types And Syntax Of Ignore Lists]])
4. create symbolic links back to the files moved (stow the dotfiles directory)
5. (optional) backup the folder (like pushing to github)

And this is is an example of mine:

#+begin_src shell
  # step 1: create dotfiles folder in the home directory
  cd ~
  mkdir .dotfiles
  # step 2: move files to the directory created
  mv .vimrc .dotfiles/
  # same folder structure inside .dotfiles as $HOME folder
  mkdir .dotfiles/.config/i3 -p
  mv .config/i3/config .dotfiles/.config/i3/
  # ... more
  cd .dotfiles
  # step 3: add .stow-local-ignore file
  vim .stow-local-ignore
  # step 4: create symbolic links
  stow .
  # ls -al ~
#+end_src

The =.stow-local-ignore= file if for telling stow that you don't want to symlink some files, you want to ignore them, here's mine.

#+begin_src conf
  \.git
  \.gitignore
  .*\.org
  ^/LICENSE.*
  ^/COPYING
#+end_src

** restore from a dotfiles backup

Restoring dotfiles is very simple, just recreate the symbolic links.

1. restore the dotfiles directory (git clone)
2. create symbolic links back

** Other useful commands of stow

#+begin_src shell
  # unlink files (v for verbose)
  stow -vD .
#+end_src

* DONE Manage Dotfiles With A Bare Git Repo      :dotfiles:@workspace_setup:
CLOSED: [2022-01-20 Thu 15:33]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: manage-dotfiles-with-a-bare-git-repo
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2022-01-20 Thu 14:48]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/dotfiles-logo-icon.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "manage dotfiles with a bare git repository"
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-01-20 Thu 15:33]
:END:

** Introduction

Using a bare git repo to manage dotfiles[fn:dotfiles] is simple (idea from [[https://www.atlassian.com/git/tutorials/dotfiles][this post]], it only requires =git=), but now I've switch to stow[fn:gnu-stow], which in my view, grouping dotfiles together in one folder in easier and cleaner for me to find.

** Start

Create the repo

#+begin_src shell
  git init --bare $HOME/.dotfiles.git
#+end_src

Set git alias for the repo

#+begin_src shell
  echo "alias dotfiles='/usr/bin/git --git-dir=$HOME/.dotfiles.git/ --work-tree=$HOME'" >> $HOME/.zshrc # or .bashrc
  . $HOME/.zshrc
#+end_src

Then use this command to not show untracked files on =dotfiles status=

#+begin_src shell
  dotfiles config --local status.showUntrackedFiles no
#+end_src

** Backup Files

use =dotfiles= like your original =git= command

#+begin_src shell
  dotfiles status
  dotfiles add .vimrc
  dotfiles commit -m "backup .vimrc"
  dotfiles remote add origin https://www.github.com/sky-bro/.dotfiles.git
  dotfiles push origin master
#+end_src

** Restore Files

On this computer

#+begin_src shell
  # rm .vimrc
  dotfiles checkout
#+end_src

On another computer

#+begin_src shell
  echo 'alias dotfiles="/usr/bin/git --git-dir=$HOME/.dotfiles.git/ --work-tree=$HOME"' >> $HOME/.zshrc
  source ~/.zshrc
  echo ".dotfiles.git" >> .gitignore # prevent recursion issues
  git clone --bare git@github.com:sky-bro/.dotfiles.git $HOME/.dotfiles.git
  dotfiles checkout
  dotfiles config --local status.showUntrackedFiles no
#+end_src

* DONE Flash Rom For My Android                               :twrp:@Android:
CLOSED: [2022-01-31 Mon 23:04]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: flash-rom-for-my-android
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2022-01-31 Mon 19:39]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/android-logo.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "Notes on tweaking my android (op6)"
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-01-31 Mon 23:04]
:END:

** flash twrp recovery

Download TWRP[fn:twrp] recovery for your android device, and probably follow the installation guide there.

Generally, there are two ways of installing the recovery: from a  =.img= file or a =.zip= file.

*** backup your boot.img

There's no recovery partition, recovery is now part of the boot partition.

So in case we break our boot partition, backup it first.

#+begin_src shell
  # === On your android shell (adb shell) ===
  # cd `find /dev/block/platform -type d -name by-name` # mine is /dev/block/platform/soc/1d84000.ufshc/by-name
  # or just
  # cd /dev/block/by-name/
  cd /dev/block/bootdevice/by-name/
  # store the boot partition to /sdcard/boot.img file
  dd if=boot of=/sdcard/boot.img

  # === On you computer shell ===
  # copy the boot.img to your computer
  adb pull /sdcard/boot.img
#+end_src

You can restore the boot partition with =fastboot=.

#+begin_src shell
  # === on your computer shell ===
  fastboot flash boot boot.img
#+end_src

*** Install with the recovery.img file

First temporarily boot into the new recovery.

#+begin_src shell
  adb reboot bootloader
  fastboot boot recovery.img
#+end_src

Once booted, make this recovery permanent:
- navigate to Advanced > Flash Current TWRP option (preferably), or
- navigate to Advanced > Install Recovery Ramdisk > select the =recovery.img= file from your phone storage, or
- as in the next section: install with the =recovery.zip= file.

*** Install with the recovery.zip file

If you already have a working recovery, you only need to have this file on you phone storage (no computer needed). And flash this zip file from your recovery.

Navigate to Install > select the =recovery.zip= file.

** flash rom

You can get many useful resources for OnePlus from 大侠阿木云盘[fn:daxiaamu].

*** Wipes

- Dalvik Cache
- Cache

*** Install rom.zip

put the =rom.zip= file on your phone storage.

boot to recovery, navigate to Install > select the =rom.zip= file.

*** Trouble Shooting

- After flashing a offcial rom for my oneplus 6, my device keeps boots to recovery instead of the system.
  - Solution: go to recovery, Wipe > Format Data.

* DONE Root Android with Magisk                        :root:magisk:@Android:
CLOSED: [2022-02-02 Wed 19:05]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: root-android-with-magisk
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2022-02-02 Wed 11:14]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/hash-symbol.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "notes on gaining root access on my android with Magisk"
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-02-02 Wed 19:05]
:END:

** Introduction

Magisk[fn:magisk] is a suite of open source software for customizing Android, supporting devices higher than Android 5.0.

Some highlight features:

- MagiskSU: Provide root access for applications
- Magisk Modules: Modify read-only partitions by installing modules
- MagiskBoot: The most complete tool for unpacking and repacking Android boot images
- Zygisk: Run code in every Android applications' processes

This is my notes on installing it on my op6 following the [[https://topjohnwu.github.io/Magisk/install.html][official installation guide]].

** Download and install Magisk app

Download latest Magisk apk from [[https://github.com/topjohnwu/Magisk/releases/latest][github release]]. Install it:

#+begin_src shell
  adb insatll Magisk.apk
#+end_src

After launching the app, notice the Ramdisk value (mine is Yes), it means whether or not your device has boot ramdisk.

- if Yes, patch boot partition (I'll choose this)
- if No, patch recovery partition

#+ATTR_HTML: :width 30%
[[file:../static/images/posts/root-android-with-magisk/magisk-first-installed.png]]

** backup images

This will need root access, so reboot to twrp recovery first.

#+begin_src shell
  # go to twrp recovery to get root access to your image partition
  # adb reboot recovery
  adb shell # commands below are executed in the android shell
  # get current slot (A/B)
  /bin/getprop ro.boot.slot_suffix
  # _a, so I will backup /dev/block/by-name/boot_a
  dd if=/dev/block/by-name/boot_a of=/sdcard/boot.img
  # optional, if you have vbmeta partition
  # dd if=/dev/block/by-name/vbmeta_a of=/sdcard/vbmeta.img
  # adb pull /sdcard/vbmeta.img
#+end_src

** patch image and install

patch image inside magisk app.

- press install button in the magisk card
- select the image just extracted

pull the patched image to your computer, reboot to bootloader, flash the new patched image to your android device.

#+begin_src shell
  adb pull /sdcard/Download/magisk_patched-xxx.img
  adb reboot bootloader
  fastboot flash boot magisk_patched-xxx.img
  # if you patched the recovery partition
  # fastboot flash recovery magisk_patched-xxx.img
  # optional, patch and install the vbmeta partition
  # fastboot flash vbmeta --disable-verity --disable-verification vbmeta.img
  fastboot reboot
#+end_src

Now open Magisk app again, you can see it's installed.

#+ATTR_HTML: :width 30%
[[file:../static/images/posts/root-android-with-magisk/magisk-patch-installed.png]]

* DONE Activate Windows With Your KMS Own Server :@workspace_setup:kms:windows:
CLOSED: [2022-04-17 Sun 09:15]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: activate-windows-with-your-own-kms-server
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2022-02-25 Fri 16:11]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/windows-volume-licensing.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "Activate windows and office with a KMS emulator (for volume license editions)"
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-04-17 Sun 09:15]
:END:

** Introduction

KMS[fn:key-management-service] uses a client-server model, to use it, you need to have a KMS host (server) available on your network.

Computers that activate with a KMS host need to have a specific product key (KMS client key, or formally as Microsoft Generic Volume License Key - GVLK).

Volume licensing editions are, by default, KMS clients with no extra configuration needed as the relevant GVLK is already there.

** Get a product key

Get a product key from [[https://docs.microsoft.com/en-us/windows-server/get-started/kms-client-activation-keys][kms client activation product keys]] for you running windows edition.

To check your current windows version: run =winver=

** Start KMS server

There are several KMS emulators, choose any:
- [[https://github.com/SystemRage/py-kms][py-kms]]
- [[https://github.com/Wind4/vlmcsd][vlmcsd]]

I recommend using py-kms with docker:

#+begin_src shell
  docker run -d --name py-kms --restart always -p 1688:1688 pykmsorg/py-kms
#+end_src

arguments explained:
- =-d= run in the background
- =-name py-kms= container name is =py-kms= (name whatever you want)
- =--restart always= always restart the container if it's not running (unless manually stopped, but will still restart if docker daemon restarts)
- =-p 1688:1688= map host port 1688 (left) to the port 1688 (right) in the container
- =pykmsorg/py-kms= the docker image to run

** activate with slmgr

In your administrator powershell (=win + r=, =powershell=, =Ctrl+Shift+Enter=):

#+begin_src shell
  # uninstall product key
  # slmgr.vbs /upk
  # set/change the product key
  slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX
  # set the kms server address, 1688 is the default port (can be omitted)
  slmgr /skms 192.168.122.1:1688
  # activate windows
  slmgr /ato
  # activation status
  slmgr /dli
  # activation status (verbose)
  # slmgr /dlv
#+end_src

** Resources

- To install office, choose volume licensing edition, after setting KMS server, it will be activated automatically: [[https://otp.landian.vip/zh-cn/][Office Tool Plus]]

* DONE Tmux Notes                           :cheatsheet:terminal:tmux:@notes:
CLOSED: [2022-03-26 Sat 19:19]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: tmux-notes
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2022-03-26 Sat 17:11]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/tmux-logo.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "A portable & minimal tmux configuration"
:END:

** .tmux.conf

My most up to date config file is at github: [[https://github.com/sky-bro/.dotfiles/blob/master/.tmux.conf][.dotfiles/.tmux.conf]], and for better experience, I strongly suggest you use =Capslock= as your =Ctrl= key (I set =C-a= as my prefix instead of =C-b=).

#+begin_src conf
  # chenge prefix from =C-b= to =C-a=
  set -g prefix C-a
  unbind C-b
  bind C-a send-prefix

  # better window split, with "-" and "|"
  unbind '"'
  bind - splitw -v -c '#{pane_current_path}'
  unbind %
  bind | splitw -h -c '#{pane_current_path}'

  # enable mouse
  set-option -g mouse on

  # use hjkl to
  # change focus
  bind -r k select-pane -U
  bind -r j select-pane -D
  bind -r h select-pane -L
  bind -r l select-pane -R
  # resize pane
  bind -r ^k resizep -U 2 # upward (prefix Ctrl+k)
  bind -r ^j resizep -D 2 # downward (prefix Ctrl+j)
  bind -r ^h resizep -L 2 # to the left (prefix Ctrl+h)
  bind -r ^l resizep -R 2 # to the right (prefix Ctrl+l)

  # enable vi motions
  setw -g mode-keys vi
  # select, copy with v, y
  bind -T copy-mode-vi v send-keys -X begin-selection
  bind -T copy-mode-vi y send-keys -X copy-selection-and-cancel

  set -g base-index 1
  set -g pane-base-index 1

  set -g status-interval 1
  set -g status-justify left
  setw -g monitor-activity on

  # Set default term to xterm
  # https://github.com/zsh-users/zsh-autosuggestions/issues/229
  # https://stackoverflow.com/questions/18600188/home-end-keys-do-not-work-in-tmux
  set -g default-terminal screen-256color
#+end_src

** Key Bindings

#+begin_quote
=prefix= means =C-b= by default, or =C-a= for me.
list all shortcust: =prefix ?=
#+end_quote

*** sessions

- list session: =tmux ls=, =prefix s=
- new session: =tmux new -s session_name= (attach now), =tmux new -ds session_name= (do not attach)
- attach session: =tmux a -t session_name=
- create or attach session: =tmux new -A -s session_name=
- detach session: =prefix d=
- rename session: =prefix $=
- kill session: =tmux kill-session -t session_name=
- previous/next session: =prefix (/)=

*** windows

- new window: =prefix c=
- next/previous window: =prefix n/p=
- rename window: =prefix ,=
- kill window: =prefix &=

*** panes

- change focus between panes: =prefix h/j/k/l=
- resize pane: =prefix C-h/j/k/l=
- split pane: =prefix |=
- vsplit pane: =prefix -=
- toggle zoom: =prefix z=
- kill pane: =prefix x=
- scroll pane: use mouse wheel or =prefix [= then with vi motions
- toggle between pane layouts: =prefix SPACE=
- display panes /   show pane numbers: =prefix q= (given a number, jump to that pane)
- swap with previous/next pane: =prefix {/}=

*** copy & paste

- within tmux
  - select & copy with your mouse
  - or first enter navigation: =prefix [=, then
    - navigate with vi motions: =hjkl=, =C-f=, =C-b=, ...
    - =v= or =shift+v= to start character/line level selection
    - =o= to change active end of selection
    - =y= to yank (copy) or =q= to quit navigation
    - =prefix ]= to paste selection
- bettwen tmux and your host
  - hold shift and use mouse to select
  - copy with =Ctrl+Shift+c= or =Ctrl+c= (depends on your system/terminal settings)
  - paste with =Ctrl+Shift+v= or =Ctrl+v= (depends on your system/terminal settings)
- command line
  - =tmux save-buffer -= save paste buffer to file (here use =-= as a filename to mean stdin/stdout).
  - =tmux paste-buffer=
  - =tmux set-buffer=
  - =tmux choose-buffer=

#+begin_src shell
  # copy to clipboard
  tmux save-buffer - | xclip -i -sel clipboard
  # paste from clipboard
  tmux set-buffer "$(xclip -o -sel clipboard)"; tmux paste-buffer
#+end_src

* DONE Manage Passwords with Pass            :password:pass:@workspace_setup:
CLOSED: [2022-04-18 Mon 11:39]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: manage-passwords-with-pass
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2022-04-05 Tue 20:28]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/password-store.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "manage passwords on all your devices (add, generate, edit, delete, sync)."
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-04-18 Mon 11:39]
:END:

** introduction

Pass[fn:pass] is a command line tool that manages (adding, editing, generating, retrieving) your passwords, but with many useful font-ends and ported clients for different platforms. Its very handy to use it for managing all your passwords on all your devices.

Each password lives in a gpg encrypted file.

** init

Before everything, we need to initialize the password store with a GPG key ([[https://www.linode.com/docs/guides/gpg-keys-to-send-encrypted-messages/][How to generate a gpg key]]):

#+begin_src shell
  # "Kyle Shi" is the user id (maybe email is better?) for my GPG key
  # this will create a directory: $HOME\.password-store
  # with a file .gpg-id in it (which stores this id)
  pass init "Kyle Shi"
#+end_src

Passwords that you add will be stored in the =.password-store= directory, named =xxx.gpg=, which is encrypted with your gpg public key, which only you can decrypt with your private key (=gpg --output doc --decrypt doc.gpg=).

** manage with pass command

*** add

#+begin_src shell
  pass insert Email/sky_io@outlook.com
#+end_src

*** generate

#+begin_src shell
  # generate password for an entry with length of 15
  # if -n (--no-symbols) is passed: will not use non alphanumeric characters
  pass generate Email/sky_io@outlook.com 15
#+end_src

*** edit

#+begin_src shell
  # edit an entry with your default editor
  pass edit Email/sky_io@outlook.com
#+end_src

*** remove

#+begin_src shell
  pass rm Email/sky_io@outlook.com
#+end_src

*** retrieve

#+begin_src shell
  # list password entries
  pass
  # show password for an entry
  pass Email/sky_io@outlook.com
  # copy password of an entry to the clipboard
  pass -c Email/sky_io@outlook.com
#+end_src

history problem with clipboard manager: [[https://github.com/hluk/CopyQ/issues/1031][How to clear the history in CopyQ?]]

** manage with other pass front ends

We barely use =pass= command, instead we use other more user friendly front ends.

*** unix/unix like: [[https://github.com/carnager/rofi-pass][rofi-pass]]

- =Alt+n=: add new password
- =Alt+a=: action menu of current password
- =Alt+h=: help

*** windows

- [[https://github.com/geluk/pass-winmenu][pass-winmenu]]

*** android

- [[https://github.com/android-password-store/Android-Password-Store][Android-Password-Store]]

*** ios

- [[https://mssun.github.io/passforios/][passforios]]

** Sync

*** git(hub)

#+begin_src shell
  cd $HOME\.password-store
  git init
  git branch -M main
  git add -A
  git commit -m "init pass store"
  git remote add origin git@github.com:sky-bro/password-store.git
  git push -u origin main
#+end_src

Adding and removing passwords will automatically create git commits.

** browser settings

switch off =Offer to save passwords= in chrome settings

* DONE Linux Hypervisor Setup          :qemu:kvm:hypervisor:@workspace_setup:
CLOSED: [2022-04-10 Sun 23:43]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: linux-hypervisor-setup
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2022-04-08 Fri 20:27]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/kvm.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "setup hypervisor with qemu and kvm, the best linux based open source virtualization solution"
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-04-10 Sun 23:43]
:END:

** Introduction

KVM[fn:kvm] is part of linux kernel, and QEMU[fn:QEMU] (Quick EMUlator) is an emulator. KVM by itself cannot provide the complete virtualization solution, it needs QEMU to provide full hypervisor functionality. QEMU can emulate cpu on its own, but with KVM, QEMU can achieve near native performance by executing the guest code directly on the host CPU.

So it's best for them to work together.

#+CAPTION: architecture
[[file:../static/images/posts/linux-hypervisor-setup/architecture.svg]]

** tools you need

Use your own package manager to install these tools:

#+begin_src shell
  # arch users
  sudo pacman -Sy --needed \
          qemu \
          virt-viewer \
          libvirt \
          dnsmasq \
          ebtables \
          virt-install \
          virt-manager \
#+end_src

- *kvm* (Kernel-based Virtual Machine): Kernel module that handles CPU and memory communication
- *qemu* (Quick EMUlator): emulates many hardware resources -- dick, network, usb...
- *libvirt*: an open-source API, daemon and management tool for managing platform virtualization. It can be used to manage KVM, Xen, VMware ESXi, QEMU and other virtualization technologies.
  - *virsh*: comes with libvirt, command-line tools for communicating with libvirt
- *virt-manager*: GUI alternative to virsh, albeit less capable.
- *virt-install*: part of virt-manager project, create new VM guests
- *virt-viewer*: part of virt-manager project, UI for interacting with VMs via VNC/SPICE
- *dnsmasq*: light-weight DNS/DHCP server. Primarily used for allocating IPs to VMs.
- *ebtables*: used for setting up NAT networking the host

** some setup

two problems

1. by default, virt-manager talks to =qemu:///system=, and virsh talks to =qemu:///session= (unless run as sudo).
2. when talking to qemu:///system, we need to input password every time, especially unpleasant experience when a cli tool like virsh.

for the first problem, we can tell virsh to use =qemu:///system= by default

#+begin_src shell
  cp /etc/libvirt/libvirt.conf ~/.config/libvirt/libvirt.conf
  vim ~/.config/libvirt/libvirt.conf # uncomment or add: uri_default = "qemu:///system"
#+end_src

To solve the second problem, we can add a rule to [[https://wiki.archlinux.org/index.php/Polkit][polkit]] to allow our group (=wheel= -- administrator group) to use virt-manager or vish without being asked for password.

edit =/etc/polkit-1/rules.d/xxx.rules=, your path may be different, put this in.

#+begin_src js
  /* Allow users in wheel group to manage the libvirt daemon without authentication */
  polkit.addRule(function (action, subject) {
    if (action.id == "org.libvirt.unix.manage" && subject.isInGroup("wheel")) {
      return polkit.Result.YES;
    }
  });
#+end_src

** start services

#+begin_src shell
  systemctl enable libvirtd # start on boot
  systemctl enable virtstoraged # start on boot
  systemctl enable virtnetworkd # start on boot
  systemctl start libvirtd  # start libvirtd
  systemctl start virtstoraged # start on boot
  systemctl start virtnetworkd # start on boot
  virsh net-autostart --network default
  virsh net-start --network default # start the default network
#+end_src

** add shrarefolders

Inside virtual machine manager, double click on one of your machine, then select =view->details->Add Hardware=, set something like below:

#+CAPTION: add sharefolder
[[file:../static/images/posts/linux-hypervisor-setup/add-sharefolder.png]]

The above setting will add a new device =/ctf= in the virtual machine

*** if in ubuntu

=sudo vim /etc/rc.local=

#+begin_src shell
  #!/bin/sh -e
  #
  # rc.local
  #
  # This script is executed at the end of each multiuser runlevel.
  # Make sure that the script will "exit 0" on success or any other
  # value on error.
  #
  # In order to enable or disable this script just change the execution
  # bits.
  #
  # By default this script does nothing.

  mount -t 9p -o trans=virtio,version=9p2000.L /ctf /home/sky/ctf

  exit 0
#+end_src

After restarting this server, =/ctf= will automatically be mounted on =/home/sky/ctf=

To make the user (actually kvm) writing the share folder same as the user at host (vm host):
=sudo vim /etc/libvirt/qemu.conf=, find two lines with =user=xxx= and =group=xxx=, change them to yourself (by default, xxx should be =root=), then uncomment the two lines. for me, they are:

#+begin_src conf
  user = "sky"
  group = "sky"
#+end_src

You may need to restart the libvirtd.service for this to take effect.

Also, you need to =chown= the disk to the above =user:group=: =sudo chown sky:sky /var/lib/libvirt/images/ubt16-server.qcow2=

** create a VM

- gui: virt-manager
- cli: virt-install

examples:
- Windows 11 VM with QEMU/KVM

** clone a VM

- gui: virt-manager
- cli: virt-clone

** useful virsh commands

#+begin_src shell
  virsh list --all
  virsh start ubuntu-server
  virsh shutdown ubuntu-server
  virsh reboot ubuntu-server
#+end_src

** Resources

- [[https://octetz.com/docs/2020/2020-05-06-linux-hypervisor-setup/][Linux Hypervisor Setup (libvirt/qemu/kvm)]]
- [[https://askubuntu.com/questions/548208/sharing-folder-with-vm-through-libvirt-9p-permission-denied][Sharing folder with VM through libvirt, 9p, permission denied]]
- [[https://github.com/foxlet/macOS-Simple-KVM][macOS-Simple-KVM]]

* DONE Windows 11 VM with QEMU/KVM         :virtual:machine:windows:kvm:qemu:
CLOSED: [2022-04-10 Sun 23:43]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: windows-11-vm-with-qemu-kvm
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2022-04-10 Sun 14:22]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/windows-logo.jpg"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "Install windows VM in QEMU/KVM"
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-04-10 Sun 23:43]
:END:

** Get a windows iso

[[https://www.microsoft.com/en-in/software-download/windows11][MS: Download Windows 11]]

** Create new VM with virt-manager

open virt-manager

make sure you've connected to the QEMU/KVM (click the File option, then 'Add Connection', make sure hypervisor is selected to QEMU/KVM, and click connect)

now QEMU/KVM will show up that you can add a vm to:

#+CAPTION: create a new virtual machine with virt-manager
[[file:../static/images/posts/windows-11-vm-with-qemu-kvm/virt-manager-create-a-new-virtual-machine.png]]

*** walk through basic options

**** select Local install media (ISO image or CDROM)

#+CAPTION: select windows 11 iso
[[file:../static/images/posts/windows-11-vm-with-qemu-kvm/virt-manager-select-windows-iso.png]]

**** Configure Memory and CPU

#+CAPTION: configure memory and cpu
[[file:../static/images/posts/windows-11-vm-with-qemu-kvm/virt-manager-memory-and-cpu.png]]

**** Create a virtual hard disk

#+CAPTION: create a disk
[[file:../static/images/posts/windows-11-vm-with-qemu-kvm/virt-manager-create-virtual-hard-disk.png]]

**** Set VM name, Network, etc.

and make sure you select the option: Customize configuration before install.

#+CAPTION: Name, Network, Customize
[[file:../static/images/posts/windows-11-vm-with-qemu-kvm/virt-manager-name-network-customize.png]]

*** configure hardware

if you've selected the "Customize configuration before install" option, you'll be lead to this hardware configuration prompt.

**** hard disk bus type

- Click on SATA Disk 1.
- Choose the disk bus as VirtIO

#+CAPTION: set disk bus tpe to VirtIO
[[file:../static/images/posts/windows-11-vm-with-qemu-kvm/virt-manager-set-disk-bus-type-as-virtio.png]]

**** network device model

also set network device model to virtio

#+CAPTION: set network device model to virtio
[[file:../static/images/posts/windows-11-vm-with-qemu-kvm/virt-manager-network-device-model.png]]

**** add virtio driver

- click on Add Hardware
- select storage, click on manage, and attach the virtio driver you've downloaded
- choose device type as CDROM

#+CAPTION: add virtio driver
[[file:../static/images/posts/windows-11-vm-with-qemu-kvm/virt-manager-attach-virtio-driver-iso.png]]

**** change boot order

make sure CDROM 1 is checked and at top.

#+CAPTION: change boot order
[[file:../static/images/posts/windows-11-vm-with-qemu-kvm/virt-manager-change-boot-order.png]]

**** (optional) enable TPM

Click on Add  Hardware, Add the TPM as below.

Model – You will see two models, choose TIS,
Backend – select Backend as Emulated.
Version – 2.0

#+CAPTION: add TPM
[[file:../static/images/posts/windows-11-vm-with-qemu-kvm/virt-manager-add-TPM.png]]

****  (optional) enable Secure Boot

you need to install ovmf and swtpm

#+begin_src shell
  sudo pacman -Sy swtpm ed2k-ovmf
#+end_src

#+CAPTION: enable secure boot
[[file:../static/images/posts/windows-11-vm-with-qemu-kvm/virt-manager-enable-secure-boot.png]]

** Begin installation

*** bypass checks

Click Begin Installation button on the top left corner to start the installation process, then install Windows like you would on a normal PC.

If you haven't enabled TPM 2.0 and secure boot, you'll not meet the installation requirements of windows 11. But you can bypass these checks.

open command prompt with =Shift+F10=

#+begin_src bat
  REG ADD HKLM\SYSTEM\Setup\Labconfig /v BypassTPMCheck /t REG_DWORD /d 1
  REG ADD HKLM\SYSTEM\Setup\Labconfig /v BypassSecureBootCheck /t REG_DWORD /d 1
#+end_src

Similarly, you can disable other checks with: BypassSecureCPUCheck, BypassSecureRAMCheck, BypassSecureStorageCheck

*** Load driver

You won't be able to find the virtio hard disk that you have added, click on Load driver. In the prompt, choose windows 11 driver, and click on Next.

*** Skip connecting to network

we don't have the corresponding virtio driver yet, we'll install it in the next section.

** After installation

*** Install VirtIO Drivers

- Open the Windows Explorer and navigate to the CD-ROM drive.
- Simply execute (double-click on) virtio-win-gt-x64
- (optional) Use the virtio-win-guest-tools wizard to install the QEMU Guest Agent and the SPICE agent for an improved remote-viewer experience.
- (optional) Reboot VM

*** remove CDROMs

- Remove the windows installer iso after intallation.
- Keep the virtio iso.

*** file sharing

recommend sharing files between host and windows guest with samba.

** resources

- [[https://askubuntu.com/questions/1146441/how-to-properly-configure-virt-manager-qemu-kvm-with-windows-guest][How to properly configure Virt-Manager (QEMU/KVM) with Windows guest]]

* DONE File Sharing with Samba                       :@workspace_setup:samba:
CLOSED: [2022-04-12 Tue 19:28]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: file-sharing-with-samba
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2022-04-12 Tue 12:20]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/samba-logo.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "use samba to share files across linux and windows."
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-04-12 Tue 19:28]
:END:

** Introduction

You should use NFS for dedicated Linux Client to Linux Server connections.

For mixed Windows/Linux environments use Samba.

** Server (linux)

*** install

#+begin_src shell
  sudo pacman -Sy samba
#+end_src

*** configure

**** configuration file

Need to create =/etc/samba/smb.conf= before starting the service =systemctl start smb=

You can get an example configuration file from [[https://git.samba.org/samba.git/?p=samba.git;a=blob_plain;f=examples/smb.conf.default;hb=HEAD][Samba Git Repository]].

Get help about writing the configuration file with =man smb.conf=.

Here's mine:

#+begin_src toml
  [global]
    workgroup = k4i.top
    map to guest = Bad Password
    server string = Samba Server
    passdb backend = tdbsam

  [homes]
     comment = Home Directories
     browseable = no
     writable = yes

  [tmp]
    comment = Temporary file space
    path = /tmp
    public = yes
    writable = yes
    printable = no
#+end_src

**** user management

we need to have a user to access linux files.

1. For anonymous access, we use the guest account (by default, it's user =nobody=)
2. If you want to access files in a home directory, you should login as that user.

We need to specifically add a user (an existing linux user, or a non-existing one -- samba will create the user for you) to samba, then set a password for that user (can be different from your linux login password)

#+begin_src shell
  sudo smbpasswd -a sky
#+end_src

And by default, when you access a samba server with a user, you can browser that user's home directory (if it has one).

*** start

#+begin_src shell
  systemctl start smb.service
  # if you want to access service with host names, start this service
  systemctl start nmb.service
#+end_src

** Client

*** windows

In the file manager location bar, input: =\\servername\[share]=, then you may remap any folder to a drive.

tips: to clean user credentials (or with the control panel GUI)

#+begin_src bat
  net use /delete *.
#+end_src

*** linux

1. With a file manager:

https://wiki.archlinux.org/title/samba#File_manager_configuration

In the location bar, input: =smb://servername/share=

2. With a command line tool: =smbclient=

#+begin_src shell
  smbclient //xyz/public -U nobody
  smbclient //xyz/sky -U sky
#+end_src

** Resources

- [[https://jeffshee.github.io/2021-01-29-samba-fedora33-kvm-windows-10/][File transfer between Linux and KVM Guest Windows 10]]
- [[https://wiki.archlinux.org/title/samba][Arch Wiki: samba]]

* DONE Use Random in C++                        :@Crypto:@C:STL:Random:C:RNG:
CLOSED: [2022-04-18 Mon 15:47]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: use-random-in-c-plus-plus
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2022-04-18 Mon 15:42]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "images/icons/dice-white.svg"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "introduce randomness into your C++ programs, the right way."
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-04-18 Mon 15:47]
:END:

** Old way

use =rand()=, usually pair with a random initialization of the seed:

#+begin_src c
  srand(int(time(0))); // initialize the seed
  rand(); // get a random int, [0, RAND_MAX]
#+end_src

get random int in =[0,x)=: =rand()%x=
get random real in =[0, 1]=: =rand()/double(RAND_MAX)=

** Modern way

*** Generators

**** random_device

random_device is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.
A good implementation should has its randomness come from a non-deterministic source (e.g. a hardware device).
We can just use this to get our random numbers, but it might come with a light performance price. A PRNG is much better

**** pseudo RNG

So, we usually use random_device to get our first random number, then use it to initialize other PRNGs, then we can more quickly get many more random numbers.
The STL implements several PRNGs (see [[https://en.cppreference.com/w/cpp/numeric/random][cppref: Predefined random number generators]]), not just the *Mersenne Twister* shown above, you can check

*** Distributions

#+begin_src c++
  // ...
  #include <random>

  std::random_device rd; // get a seed
  std::mt19937 g(rd());
#+end_src

** Use cases of PRNG

TODO...

** Refs

- [cppref: std::random_device](https://en.cppreference.com/w/cpp/numeric/random/random_device)
- [cppref: Predefined random number generators](https://en.cppreference.com/w/cpp/numeric/random)
- [std::random_shuffle is deprecated in C++14](https://meetingcpp.com/blog/items/stdrandom_shuffle-is-deprecated.html)

* DONE Public, Private and Hybrid Cloud                    :@Cloud_Computing:
CLOSED: [2022-10-21 Fri 08:57]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: public-private-and-hybrid-cloud
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2022-10-20 Thu 23:09]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/tortoise.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "this is a description"
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-10-21 Fri 08:57]
:END:

** Introduction

- Public Cloud :: delivered via the internet and shared across organizations
- Private Cloud :: dedicated solely to your organization
- Hybrid Cloud :: any environment that uses both public and private clouds

** Public Cloud

*** Service Features

- Pros
  - No investments required to deploy and maintain the IT infrastructure (cloud vendor's responsibility)
  - High scalability and flexibility (to meet unpredictable workload demands)
  - Flexible pricing options
- Cons
  - total cost of ownership (TCO) can rise exponentially for large scale usage
  - lease secure
  - low visibility and control into the infrastructure

*** Vendor Responsibility

responsible for developing, managing, and maintaining the pool of computing resources shared between multiple tenants from across the network.

** Private Cloud

*** Service Features

- Pros
  - Dedicated and secure environments
  - Customizable & Flexible
  - high performance
- Cons
  - high price for short-term use cases
  - may not offer high scalability

*** Vendor Responsibility

** Hybrid Cloud

*** Service Features

- Pros
  - Flexible policy to deploy workloads on public or private infrastructure (based on security, performance and cost)
  - scale with security (public cloud resources to accommodate occasional spikes)
  - reliable (multiple data centers -- public and private)
  - cost control (sensitive workloads on private clouds, regular workloads on public cloud)
- Cons
  - toggling between public and private (how to track, what's the cost)
  - public cloud resource management (different locations and categories)
  - complexity of managing an evolving mix of private and public cloud architecture

*** Vendor Responsibility

** References

- [[https://www.bmc.com/blogs/public-private-hybrid-cloud/#:~:text=Public%20cloud%20is%20cloud%20computing,both%20public%20and%20private%20clouds.][Public vs Private vs Hybrid: Cloud Differences Explained]]

* Footnotes

[fn:plantuml] [[https://plantuml.com/][plantuml official site]]

[fn:zzo-docs] [[https://zzo-docs.vercel.app/zzo/shortcodes/][zzo-docs on shortcodes]]

[fn:ox-hugo] [[https://ox-hugo.scripter.co/][ox-hugo official site]]

[fn:orgmode] [[https://orgmode.org/][org mode official site]]

[fn:seed-random-generator] [[https://emacs.stackexchange.com/questions/58285/orgmode-latex-export-how-to-create-repeatable-labels][org export: create repeatable labels]]

[fn:org-export-new-reference] [[https://www.reddit.com/r/orgmode/comments/aagmfh/export_to_html_with_useful_nonrandom_ids_and/][Export to HTML with useful, non-random IDs and anchors]]

[fn:ranger-official-user-guide] [[https://github.com/ranger/ranger/wiki/Official-User-Guide][ranger official user guide]]

[fn:xcwd] [[https://github.com/schischi/xcwd][xcwd]] is a simple tool that prints the current working directory of the currently focused window.

[fn:st-from-luke] [[https://github.com/LukeSmithxyz/st][st]] from Luke Smith

[fn:ohmyzsh] [[https://ohmyz.sh/][Oh My Zsh]] is a delightful, open source, community-driven framework for managing your Zsh configuration

[fn:fzf] [[https://github.com/junegunn/fzf][fzf]] is a general-purpose command-line fuzzy finder

[fn:pywal] [[https://github.com/dylanaraps/pywal][Pywal]] is a tool that generates a color palette from the dominant colors in an image.

[fn:dotfiles] use +a bare git repository+ stow  to manage [[https://github.com/sky-bro/.dotfiles][my dotfiles]].

[fn:p10k] [[https://github.com/romkatv/powerlevel10k][Powerlevel10k]] is a theme for Zsh. It emphasizes speed, flexibility and out-of-the-box experience.

[fn:wal-feh] my [[https://github.com/sky-bro/.dotfiles/blob/master/bin/wal-feh][wal-feh]] script to set wallpaper and color scheme

[fn:copyq] [[https://github.com/hluk/CopyQ][CopyQ]], a clipboard manager with advanced features.

[fn:copyq-commands] [[https://github.com/hluk/copyq-commands][copyq-commands]] is a repo which has many useful commands for CopyQ clipboard manager

[fn:manually-boot-up-linux] [[https://forums.justlinux.com/showthread.php?150600-How-to-manually-boot-up-a-Linux][How to manually boot up a Linux]]

[fn:gnu-stow] [[https://www.gnu.org/software/stow/][GNU Stow]] is a symlink farm manager.

[fn:twrp] [[https://twrp.me/][TWRP]] is the leading custom recovery for Android phones

[fn:daxiaamu] I downloaded official ROM (many history versions) for my op6 from [[https://yun.daxiaamu.com/][大侠阿木云盘]]

[fn:magisk] [[https://github.com/topjohnwu/Magisk][Magisk]] -- The Magic Mask for Android

[fn:key-management-service] KMS (Key Management Service) activates Microsoft products on a local network.

[fn:pass] [[https://www.passwordstore.org/][pass]] is the standard unix password manager.

[fn:kvm] [[https://wiki.archlinux.org/title/KVM][KVM]] is a hypervisor built into the linux kernel.

[fn:QEMU] [[https://wiki.qemu.org/][QEMU]] is a generic and open source machine emulator and virtualizer.

[fn:rfc2818] [[https://datatracker.ietf.org/doc/html/rfc2818][HTTP Over TLS]]
