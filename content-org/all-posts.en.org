#+STARTUP: overview
#+HUGO_BASE_DIR: ../
#+HUGO_SECTION: en/posts
#+AUTHOR:
#+HUGO_CUSTOM_FRONT_MATTER: :author "<a href='https://k4i.top' class='theme-link'>k4i</a>"
#+LATEX_COMPILER: xelatex
#+LATEX_CLASS: elegantpaper

* DONE About
  CLOSED: [2021-11-23 Tue 16:16]
:PROPERTIES:
:EXPORT_HUGO_SECTION: en/
:EXPORT_HUGO_BUNDLE: about
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2021-11-23 Tue 14:18]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "About K4i"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :type "about"
:END:

[[../static/images/about/the-matrix-has-you.gif]]

** :triangular_flag_on_post: This Site

Generated using [[https://gohugo.io/][Hugo]], source code here: [[https://github.com/sky-bro/blog-src][blog-src]], and the theme is forked ([[https://github.com/sky-bro/hugo-theme-zzo][my
fork]]) from: [[https://github.com/zzossig/hugo-theme-zzo][hugo-theme-zzo]].

BTW, instead of writing ~.md~ files, I keep all my blogs in ~.org~ files (stored
inside [[https://github.com/sky-bro/blog-src/tree/master/content-org][blog-src/content-org]]), and export them to ~.md~ files with [[https://ox-hugo.scripter.co/][ox-hugo]].

** :sunrise: Daily Life

   + [[http://www.hit.edu.cn/][@HIT]]
   + C/C++, Golang, Python, ASM
   + Arch, Emacs, VSCode
   + CTF, ACM

** :love_letter: Contact Me

   + Email: [[mailto:sky_io@outlook.com][sky_io@outlook.com]]
   + WeChat: sky_bro
   + Facebook: [[https://www.facebook.com/profile.php?id=100005027239118][Kaiyu Shi]]
   + Twitter: [[https://twitter.com/KaiyuShi][KaiyuShi]]
   + GPG Pub: [[/Kyle.asc][Kyle.asc]] (F4CD 0E4A 3661 65D1 62E6  B6CE 7D36 AE60 55B0 60A6)

** :chicken: My Friends

[[https://thesong96.github.io/][TheSong]], [[https://lurenxiao1998.github.io/][路人枭]], [[https://pullp.github.io][wxk]]

** :musical_score: Listening recently

[[https://open.spotify.com/user/22sit26j5lamlvm3sgikxwuoq][<img src="https://spotify-readme-ky13.vercel.app/api/spotify" alt="Kyle
Listening" />]]

* DONE Writing Guide (org + ox-hugo)                        :@notes:hugo:org:
  CLOSED: [2021-12-05 Sun 20:58]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: writing-guide--org-plus-ox-hugo
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2021-11-22 Mon 20:23]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/org-mode-unicorn.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "New writing/bloging guide, Now I blog in org mode!"
:END:

I've recently switched to [[https://orgmode.org/][org mode]], now I write all my blogs in org mode ([[https://github.com/sky-bro/blog-src/blob/master/content-org/][blog-src/content-org/]]), and export them to ~.md~ files ([[https://github.com/sky-bro/blog-src/blob/master/content/][blog-src/content/]]) with ox-hugo.

So instead of editing ~.md~ files under ~content~ folder, now I write ~.org~ files stored under ~content-org~ folder.

** Create new post

Invoking org-capture-templates function, and choose hugo post template, as shown in Figure [[fig:org-capture-template-ox-hugo]]

#+CAPTION: creating new post with org-capture-template
#+NAME: fig:org-capture-template-ox-hugo
[[../static/images/posts/Writing-Guide-Org/org-capture-template-ox-hugo.gif]]

** Front matter

As in [[https://ox-hugo.scripter.co/doc/custom-front-matter/][ox-hugo: Custom Front-matter Parameters]], hugo front matters can be added like below:

#+begin_src org
  :PROPERTIES:
  :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :key1 value1 :key2 value2
  :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :key3 value3
  :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :key4 value4
  :END:
#+end_src

** Code

Inline code with '\equal' or '\tilde': ==echo 123==, ~~echo 456~~

Code block with

#+begin_src org
  ,#+begin_src c
    int main() {
      return 0
    }
  ,#+end_src
#+end_src

** Images

Store all the images under =$HUGO_BASE_DIR/static/= folder (except some generated images), so just include them using relative path from the org file.

You can add caption and name (for referencing purpose: as in figure [[fig:gopher]]) to an image.

#+CAPTION: Gogpher
#+NAME: fig:gopher
[[../static/images/icons/gopher001.png]]

#+begin_src org
  ,#+CAPTION: Gogpher
  ,#+NAME: fig:gopher
  [[../static/images/icons/gopher001.png]]
#+end_src

** Math Support (with MathJax)

We need to have MathJax library in our front matter.

#+begin_src org
  :PROPERTIES:
  :EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
  :END:
#+end_src

Inline formulas with =\$..\$=. This is inline math: $x^2 + y^2 = z^2 \frac{1}{2}$.

Displayed equations with =\$\$..\$\$= or $\LaTeX$ encironments. This is displayed math:

The code:

#+begin_src tex
  \begin{equation}\label{eq:1}
    \begin{split}
      a &= b+c-d\\
        &\quad +e-f\\
        &= g+h\\
        &= i
    \end{split}
  \end{equation}
#+end_src

will be rendered as:

\begin{equation}\label{eq:1}
  \begin{split}
    a &= b+c-d\\
      &\quad +e-f\\
      &= g+h\\
      &= i
  \end{split}
\end{equation}

{{< alert theme="warning" >}}
It seems that zzo theme does not support math equation referencing and numbering yet?
{{< /alert >}}

** Diagrams

*** Plantuml

#+begin_src plantuml :file "../static/images/posts/Writing-Guide-Org/first.svg"
  title Authentication Sequence

  Alice->Bob: Authentication Request
  note right of Bob: Bob thinks about it
  Bob->Alice: Authentication Response
#+end_src

** revealjs / presentation

** shortcodes

*** Alert

You can have alert like this:

#+begin_src org
  {{</* alert theme="info" dir="ltr" */>}}
  theme could be one of: success, info, warning, danger
  {{</* /alert */>}}
#+end_src

{{< alert theme="success" >}}
this is a success.
{{< /alert >}}

{{< alert theme="info" >}}
this is a info.
{{< /alert >}}

{{< alert theme="warning" >}}
this is a warning.
{{< /alert >}}

{{< alert theme="danger" >}}
this is a danger.
{{< /alert >}}

*** Notice

#+begin_src org
  {{</* notice success "This is a success type of notice" */>}}
  notice could be success, info, warning, error.
  {{</* /notice */>}}
#+end_src

{{< notice success "This is a success type of notice" >}}
success notice.
{{< /notice >}}

{{< notice info "This is a info type of notice" >}}
info notice.
{{< /notice >}}

{{< notice warning "This is a warning type of notice" >}}
warning notice.
{{< /notice >}}

{{< notice error "This is a error type of notice" >}}
error notice.
{{< /notice >}}

*** Simple box

#+begin_src org
  {{</* box */>}}
  Plain text
  {{</* /box */>}}
#+end_src

{{< box >}}
Plain text
{{< /box >}}

*** Code in multiple language

#+begin_src org
  {{</* codes java javascript */>}}
    {{</* code */>}}
    ,#+begin_src java
      System.out.Println("Hello World!");
    ,#+end_src
    {{</* /code */>}}
    {{</* code */>}}
    ,#+begin_src javascript
      console.log('Hello World!');
    ,#+end_src
    {{</* /code */>}}
  {{</* /codes */>}}
#+end_src

{{< codes java javascript >}}
  {{< code >}}
  #+begin_src java
    System.out.Println("Hello World!");
  #+end_src
  {{< /code >}}
  {{< code >}}
  #+begin_src javascript
    console.log('Hello World!');
  #+end_src
  {{< /code >}}
{{< /codes >}}

*** Tab

#+begin_src org
  {{</* tabs Windows MacOS Ubuntu */>}}
    {{</* tab */>}}

    ,*** Windows section

    ,#+begin_src javascript
      console.log('Hello World!');
    ,#+end_src

    {{</* /tab */>}}
    {{</* tab */>}}

    ,*** MacOS section

    Hello world!
    {{</* /tab */>}}
    {{</* tab */>}}

    ,*** Ubuntu section

    Great!
    {{</* /tab */>}}
  {{</* /tabs */>}}
#+end_src

{{< tabs Windows MacOS Ubuntu >}}
  {{< tab >}}

  *** Windows section

  #+begin_src javascript
    console.log('Hello World!');
  #+end_src

  {{< /tab >}}
  {{< tab >}}

  *** MacOS section

  Hello world!
  {{< /tab >}}
  {{< tab >}}

  *** Ubuntu section

  Great!
  {{< /tab >}}
{{< /tabs >}}
*** Expand

#+begin_src org
  {{</* expand "Expand me" */>}}
  Some Markdown Contents
  {{</* /expand */>}}
#+end_src

{{< expand "Expand me" >}}
Some Markdown Contents
#+begin_src go
  package main

  import "fmt"

  func main() {
    fmt.Println("hello sky!")
  }
#+end_src
{{< /expand >}}

*** video

{{< youtube 2liXzaIIyuE >}}

** References

+ [[https://ox-hugo.scripter.co/][ox-hugo official site]]
+ [[https://plantuml.com/][plantuml official site]]
+ [[https://zzo-docs.vercel.app/zzo/shortcodes/][zzo-docs on shortcodes]]

* DONE Org Notes                                                 :@notes:org:
  CLOSED: [2021-12-06 Mon 21:37]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: org-notes
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2021-11-22 Mon 10:50]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/org-mode-unicorn.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "My Notes on org writing."
:END:


** Basic Editing
*** Comments

+ /*C-c ;*/ :: toggle comment of an entry

#+BEGIN_COMMENT
this is comment line 01,
this is comment line 02.
#+END_COMMENT

# comment a line / line comment

*** Font types

#+begin_src org
  + /italic/
  + *bold*
  + _underlined_
  + =verbatim=
  + ~code~
  + +strike-through+
#+end_src

will be rendered as:

+ /italic/
+ *bold*
+ _underlined_
+ =verbatim=
+ ~code~
+ +strike through+

** Code

Offers two types of source code:

1. code block
2. inline code

org-entities-help function helps you insert some code.

*** inline

#+begin_src org
  src_c++[:exports code]{ typedef long long ll; }
  src_shell[:exports code]{ echo -e "test" }
#+end_src

src_c++[:exports code]{ typedef long long ll; }
src_shell[:exports code]{ echo -e "test" }

*** code block

source code blocks are one of many Org block types.

#+begin_src org
  ,#+BEGIN_SRC cpp
    #include <iostream>
    using namespace std;
    int main() {
      cout << "123\n";
      return 0;
    }
  ,#+END_SRC
#+end_src

#+BEGIN_SRC cpp
  #include <iostream>
  using namespace std;
  int main() {
    cout << "123\n";
    return 0;
  }
#+END_SRC

** List

+ M-RET :: new item at current level
+ M-S-RET :: new item with a checkbox
+ M-UP/DOWN :: move item up/down, including subitems
+ M-S-UP/DOWN :: move item up/down
+ M-LEFT/RIGHT :: decrease/increase indentation of item
+ M-S-LEFT/RIGHT :: decrease/increase indentation of item, including subitems
+ C-c C-c :: toggle checkbox
+ C-c - :: Cycle through itemize/enumerate bullets

** Table

+ /*|Name|Age C-c RET*/ create table with headers
  | NAME | Age |
  |------+-----|
  | sky  |  22 |
  | k4i  |  23 |
+ /*RET*/ go to next row
+ /*S-UP/DOWN/LEFT/RIGHT*/ swap between cells
+ /*M-UP/DOWN/LEFT/RIGHT*/ swap between rows/columns
+ /*M-S-UP/DOWN/LEFT/RIGHT*/ insert/delete row/column
+ /*C-c -*/ insert horizontal line below
+ /*C-c RET*/ insert horizontal line below, move to next row
+ /*C-c ^*/ sort column

** Footnote

for more information on footnote, please refer to the official org site[fn:orgmode].

*** footnote types:

+ named footnote :: fn:NAME
+ anonymous, inline footnote :: fn:: inline definition, fn:NAME: inline definition

*** example

 #+begin_src org
   The Org homepage[fn:1] now looks a lot better than it used to.
   ...
   [fn:1] The link is: https://orgmode.org
 #+end_src

** hyperlinks
+ formats
  + =[[link][description]]=
  + =[[link]]=
  + [[https://k4i.top/][k4i's home!]]
+ link types
  + internal links
  + external links
+ shortcuts
  + /*C-c C-l*/ :: insert/delete link
  + /*C-c C-o*/ :: open link

** todos [1/2]

*** DONE subtask 01
    CLOSED: [2021-10-23 Sat 23:18]

    + /*M-S-RET*/ :: new todo item
    + /*C-c C-t*/ :: cycle through todo states

*** BUG subtask 02 [1/2]
    + [-] item 01
      + [ ] item 01.01
      + [X] item 01.02
    + [X] item 02

** Images

+ /*C-c C-x C-v*/ :: toggle images (org-toggle-inline-images)

** Exports

*** latex

latex config

#+BEGIN_SRC shell
tlmgr update elegantpaper
tlmgr install elegantpaper # [[https://github.com/ElegantLaTeX/ElegantPaper][elegantpaper]]
tlmgr uninstall elegantpaper
pip install pygments # dependency of [[https://github.com/gpoore/minted][minted]]
#+END_SRC

add this in your front matter

#+BEGIN_SRC org
  ,#+LATEX_COMPILER: xelatex
  ,#+LATEX_CLASS: elegantpaper
  ,#+OPTIONS: prop:t
#+END_SRC

*** fixed reference ids

Org will set random ids for internal links, sometimes we want them to be fixed.

There are two solutions, one is to seed the random number generater[fn:seed-random-generator].

#+begin_src elisp
  (defun seed-random-generator (_) (random "a fixed and unchanging string"))
  (add-hook 'org-export-before-processing-hook #'seed-random-generator)
#+end_src

And another way is to override the ~org-export-new-reference~[fn:org-export-new-reference] function:

#+begin_src elisp
  (defun org-export-deterministic-reference (references)
    (let ((new (length references)))
      (while (rassq new references) (setq new (+ new 1)))
      new))
  (advice-add #'org-export-new-reference :override #'org-export-deterministic-reference)
#+end_src

* DONE Golang Notes                                           :@notes:golang:
  CLOSED: [2021-11-25 Thu 00:30]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: golang-notes
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2021-11-21 Sun 23:56]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :image "/images/icons/gopher001.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "This is my notes on learning golang."
:END:

** Basics
*** Packages

    every go program is made up of packages, and it starts from: /package main/,
    /func main()/

    packages could be imported, and grouped together using parenthesis
    ("factored" import statements)

    #+begin_src go
      import "fmt"
      import "math"
    #+end_src

    same as:

    #+begin_src go
      import (
        "fmt"
        "math"
      )
    #+end_src

    Only capitalized names are exported, therefore after importing a package, you
    can only reference its exported names.

*** Basic Types

    #+begin_src go
      package main

      import (
        "fmt"
        "math/cmplx"
      )

      // bool

      // string

      // int int8 int16 int32 int 64
      // uint uint8 uint16 uint32 uint64 unitptr

      // bytes // alias for uint8

      // rune // alias for int32, represents a unicode code point

      // float32 float64

      // complex64 complex128

      var (
        ToBe   bool       = false
        MaxInt uint64     = 1<<64 - 1
        z      complex128 = cmplx.Sqrt(-5 + 12i)
      )

      func main() {
        fmt.Printf("Type: %T Value: %v\n", ToBe, ToBe)
        fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)
        fmt.Printf("Type: %T Value: %v\n", z, z)
      }
    #+end_src

    the int, uint, and uintptr types are usually 32 bits on 32-bit systems and 64
    bits on 64-bit systems.

*** Variables

Two ways to declare a variable:
+ /var/
  + with or without initializer (implicitly initialized with zero value)
  + package or function scope
+ ~:=~ short assignment statements
  + only function scope
  + must have initializers

With an explicit initializer, no need to provide the type of the variable.

Apart from variables, there are constants, which:
+ can be declared in package or function level
+ must have explicit initializers (also constants, value known at compile time)
+ cannot be reassigned after initialization.

Multiple /var/ or /const/ statements could be grouped together like /imports/.

#+begin_src go
  // with initializer
  var i, j int = 1, 2
  // omit type (type inference)
  var i, j = 1, 2
  // short variable declarations (also type inference)
  a := 3 // int
  b := 3.14 // float64
  c := 0.1 + 0.2i

  // constants
  const Pi = 3.14
  // numeric constants are high-precision values
  const (
    Big = 1 << 100    // 1 << 100
    Small = Big >> 99 // 2
  )
#+end_src

*** Functions

#+begin_src go
  // type comes after variable name.
  func add(x int, y int) int {
    return x + y;
  }

  // consecutive named function parameters share a type
  func add(x, y int) int {
    return x + y;
  }

  // function can return any number of results
  func swap(x, y string) (string, string) {
    return y, x
  }

  // naked return: a return without arguments, can harm readability in longer
  // functions
  func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return
  }
#+end_src

**** Methods

     Go has no classes, but you can define methods on types. A method is a
     function with a special /receiver/ argument.

     #+begin_src go
       package main

       import (
         "fmt"
         "math"
       )

       type Vertex struct {
         X, Y float64
       }

       func (v Vertex) Abs() float64 {
         return math.Sqrt(v.X*v.X + v.Y*v.Y)
       }

       func (v *Vertex) Scale(f float64) {
         v.X = v.X * f
         v.Y = v.Y * f
       }

       func main() {
         v := Vertex{3, 4}
         v.Scale(10)
         fmt.Println(v.Abs()) // 50
       }
     #+end_src

     **The method and its receiver type must be defined in the same package.**

     #+begin_src go
       type MyFloat float64 // define your own float64 type
     #+end_src

**** Pointer Receivers or Arguments

     Receiver is just another argument, it can be nil.

     If you wanna modify or not copying an argument, you should pass pointer
     types.

     In general, all methods on a given type should have either value or pointer
     receivers, but not a mixture of both.

*** Type conversions

    ~T(v)~ converts the value ~v~ to the type ~T~.

    #+begin_src go
      i := 42
      f := float64(i)
      u := uint(f)
    #+end_src

    **no implicit conversion in go**

** Control FLow
*** For

Go only has for loop, no while loop, each for loop has three basic
components:
+ init statement
+ condition statement
+ post statement (execute after each iteration)

no parentheses, but curly braces ~{}~ are always required.

#+begin_src go
  package main

  import "fmt"

  func main() {
    sum := 0
    for i := 0; i < 10; i++ {
      sum += i
    }
    fmt.Println(sum)
  }
#+end_src

any of the three components can be omitted, if you only have condition or
nothing left, semicolon can be omitted.

#+begin_src go
  sum := 0
  // just like while loop
  for sum < 1000 {
    sum++
  }

  for {
    // loop forever
  }
#+end_src

you can ~continue~ or ~break~ inside a loop

*** If

like ~for~ loops, no parentheses ~()~, but curly braces ~{}~ are required

can have init statement

#+begin_src go
  if i := 0; i != 0 {
    fmt.Println("what?")
  } else if i == 0 {
    fmt.Println("got 0")
  } else {
    fmt.Println("no way here")
  }
#+end_src

*** Switch

+ shorter way to write a sequence of ~if-else~ statements.
+ no break or default fallthrough in switch
+ cases do need not to be constants or integers.
+ also support init statements like ~if~ and ~for~.

#+begin_src go
  package main

  import (
    "fmt"
    "runtime"
  )

  func main() {
    fmt.Print("Go runs on ")
    switch os := runtime.GOOS; os {
    case "darwin":
      fmt.Println("OS X.")
    case "linux":
      fmt.Println("Linux.")
    default:
      // freebsd, openbsd,
      // plan9, windows...
      fmt.Printf("%s.\n", os)
    }
  }
#+end_src

+ you can use ~fallthrough~ keyword to fallthrough
+ mutiple statements in a single case:
+ omit condition is the same as ~switch true~ (clean way to write long
  if-then-else chains)

#+begin_src go
  package main

  import (
    "fmt"
    "time"
  )

  func main() {
    t := time.Now()

    // same as: switch true
    switch {
    // default will always be last evaluated
    default:
      fmt.Println("default")
    case t.Hour() < 12:
      fmt.Println("morning")
    case t.Hour() < 17, true: // like useing '||', match any
      fmt.Println("afternoon")
      fallthrough
    case false:
      // even condition is false, fallthrough do fallthrough here
      fmt.Println("Are you ok?")
      // cannot put fallthrough in the last case or default
      // fallthrough
    }
  }
#+end_src

*** Defer

    a ~defer~ statement defers the execution of a function until the surrounding
    function returns.

    arguments evaluated immediately, but function call is not executed until the
    surrounding function returns.

    defered function calls are pushed onto a stack, so executed in last-in-first-outo order

    #+begin_src go
      package main

      import "fmt"

      func main() {
        fmt.Println("counting")

        for i := 0; i < 10; i++ {
          defer fmt.Println(i)
        }

        fmt.Println("done")
      }
    #+end_src

** Advanced types

*** Pointers

   A pointer holds the memory address of a value.

   Go has no pointer arithmetic.

   #+begin_src go
     var p *int
     i := 42
     p = &i // referencing
     fmt.Println(*p) // dereferencing
   #+end_src

*** Structs

    can be defined inside functions

    access struct fileds using a dot

    struct fields can also be accessed through a struct pointer, without explicit
    dereferencing.

    #+begin_src go
      package main

      import "fmt"

      func main() {
        type Vertex struct {
          X int
          Y int
        }
        v := Vertex{1, 2}
        p := &v // pointer to a struct
        v.X = 4
        (*p).Y = 6 // dereference the struct first - cumbersum
        p.Y = 5    // without explicit dereference
        fmt.Println(v)
      }
    #+end_src

    struct literal

    #+begin_src go
      package main

      import "fmt"

      type Vertex struct {
        X, Y int
      }

      func main() {
        var (
          v1 = Vertex{1, 2}  // {1, 2}, has type Vertex
          v2 = Vertex{Y: 1}  // {0, 1}
          v3 = Vertex{}      // {0, 0}
          p  = &Vertex{3, 4} // has type *Vertex
        )

        // {1 2} {0 1} {0 0} &{3 4}
        fmt.Println(v1, v2, v3, p)
      }
    #+end_src

*** Arrays

    ~[n]T~ is an array of ~n~ values of type ~T~.

    Arrays cannot be resized

    #+begin_src go
      package main

      import "fmt"

      func main() {
        // [1 2 0]
        fmt.Println([3]int{1, 2})
      }
    #+end_src

*** Slices

    A slice is a dynamically-sezed, flexible view into the elements of an array.

    ~[n]T~ is an array of type T and length n.

    ~[]T~ is a slice of type T, it does not store any data, it just describes a
    section of the underlying array.

    #+begin_src go
      package main

      import "fmt"

      func main() {
        // array literal
        v := [5]int{1, 2}
        // slice literal
        // v := []int{1, 2, 0, 0, 0}
        v1 := v[1:3]
        fmt.Println(cap(v))  // 5
        fmt.Println(cap(v1)) // 4, counting from first element in the slice
        fmt.Println(len(v1)) // 2
        fmt.Println(v1)      // [2 0]
      }
    #+end_src

    When slicing, you may omit the high or low bounds to use their defaults
    instead (/0/ for low, /len/ for high)

    making a slice

    #+begin_src go
      a := make([]int, 5)    // len(a)=5, cap(a)=5
      b := make([]int, 0, 5) // len(b)=0, cap(b)=5
      b = b[:cap(b)]         // len(b)=5, cap(b)=5
      b = b[1:]              // len(b)=4, cap(b)=4
    #+end_src

    appending to a slice

    #+begin_src go
      func printSlice(s []int) {
        fmt.Printf("len=%d, cap=%d, addr=%p, %v\n", len(s), cap(s), &s, s)
      }

      func main() {
        var s []int
        printSlice(s) // len=0, cap=0
        s = append(s, 0)
        printSlice(s) // len=1, cap=1
        s = append(s, 1)
        printSlice(s) // len=2, cap=2
        s = append(s, 1)
        printSlice(s) // len=3, cap=4
        s = append(s, 1, 2, 3)
        printSlice(s) // len=6, cap=8
      }
    #+end_src

    if the backing array is too small to fit all the given values a bigger array
    will be allocated. The returned slice will point to the newly allocated
    array.

    range

    #+begin_src go
      package main

      import "fmt"

      var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

      func main() {
        // for i, _ := range pow
        // for i := range pow
        // for _, v := range pow
        for i, v := range pow {
          fmt.Printf("2**%d = %d\n", i, v)
        }
      }
    #+end_src

*** Maps

    #+begin_src go
      package main

      import "fmt"

      type Vertex struct {
        X, Y int
      }

      func main() {
        var v = map[int]Vertex{
          3: {1, 2},
        }
        // x := v[2]
        x, ok := v[2]
        // ok is false
        if !ok {
          fmt.Println("no v[2]")
          fmt.Printf("x is the zero value of Vertex, which is %v\n", x)
        }
        fmt.Println(v[3])
        // insert or update an element
        v[3] = Vertex{3, 4}
        // delete a key
        delete(v, 3)
      }
    #+end_src

*** Function Type

    Functions are values too, they can be used as funtion arguments and return
    values.

    #+begin_src go
      package main

      import "fmt"

      func f(fn func(int) string, x int) string {
        return fn(x)
      }

      func main() {

        myF := func(x int) string {
          return "xy"
        }

        fmt.Println(f(myF, 3))
      }
    #+end_src

    Receiver is actually the first argument of a method:

    #+begin_src go
      package main

      import (
        "fmt"
        "math"
      )

      type Vertex struct {
        X, Y float64
      }

      func (v Vertex) Abs() float64 {
        return math.Sqrt(v.X*v.X + v.Y*v.Y)
      }

      func (v *Vertex) Scale(f float64) {
        v.X = v.X * f
        v.Y = v.Y * f
      }

      func f(fn func(Vertex) float64, v *Vertex) {
        fmt.Println(fn(*v))
      }

      func f2(fn func(*Vertex) float64, v *Vertex) {
        fmt.Println(fn(v))
      }

      func main() {
        v := Vertex{3, 4}
        f(Vertex.Abs, &v)
        f2((*Vertex).Abs, &v)
        // these two are different function
        // receiver is actually the first argument of method
        fmt.Printf("%T\n", (*Vertex).Scale)
        fmt.Printf("%T\n", v.Scale)
      }
    #+end_src

    A closure is a function value that references variables from outside its
    body.

    #+begin_src go
      package main

      import "fmt"

      func adder() func(int) int {
        sum := 0
        return func(x int) int {
          sum += x
          return sum
        }
      }

      func main() {
        pos, neg := adder(), adder()
        for i := 0; i < 10; i++ {
          fmt.Println(
            pos(i),
            neg(-2*i),
          )
        }
      }
    #+end_src

*** Interfaces

    An interface type is a set of method signatures.

    An interface value is any type that has implemented those methods
    (implemented implicitly, no "implements" keyword).

    #+begin_src go
      package main

      import (
        "fmt"
        "math"
      )

      type Abser interface {
        Abs() float64
      }

      func main() {
        var a Abser
        f := MyFloat(-math.Sqrt2)
        v := Vertex{3, 4}

        a = f  // a MyFloat implements Abser
        a = &v // a *Vertex implements Abser

        // In the following line, v is a Vertex (not *Vertex)
        // and does NOT implement Abser.
        // a = v

        fmt.Println(a.Abs())
      }

      type MyFloat float64

      func (f MyFloat) Abs() float64 {
        if f < 0 {
          return float64(-f)
        }
        return float64(f)
      }

      type Vertex struct {
        X, Y float64
      }

      func (v *Vertex) Abs() float64 {
        return math.Sqrt(v.X*v.X + v.Y*v.Y)
      }
    #+end_src

    printing value and type of an interface is the same as printing its
    underlying value and type.

    #+begin_src go
      package main

      import "fmt"

      type I interface {
        M()
      }

      type T struct {
        S string
      }

      func (t *T) M() {
        if t == nil {
          fmt.Println("<nil>")
          return
        }
        fmt.Println(t.S)
      }

      func main() {
        var i I

        var t *T
        i = t
        describe(i)
        i.M()

        i = &T{"hello"}
        describe(i)
        i.M()
      }

      func describe(i I) {
        fmt.Printf("(%v, %T)\n", i, i)
      }
    #+end_src

    The interface that specifies zero methods is known as the empty interface.

    #+begin_src go
      package main

      import "fmt"

      func main() {
        var i interface{}
        describe(i)

        i = 42
        describe(i)

        i = "hello"
        describe(i)
      }

      func describe(i interface{}) {
        fmt.Printf("(%v, %T)\n", i, i)
      }
    #+end_src

**** Type assertions

     try converting an interface to its underlying value of type T: ~s := i.(T)~

     here ~T~ must implement methods of i.

     #+begin_src go
       package main

       import "fmt"

       func main() {
         var i interface{} = "hello"

         s := i.(string)
         fmt.Println(s)

         s, ok := i.(string)
         fmt.Println(s, ok)

         f, ok := i.(float64)
         fmt.Println(f, ok)

         f = i.(float64) // panic
         fmt.Println(f)
       }
     #+end_src

     #+begin_src go
       package main

       import "fmt"

       type Vertex struct {
         x, y int
       }

       // value of type *Vertex can also call method M()
       func (Vertex) M() {}

       func main() {
         var v Vertex

         var i interface {
           M()
         } = v

         // argument here must implement methods of the interface
         t, ok := i.(*Vertex)
         des(t) // *main.Vertex, <nil>
         chk(t, ok)

         t2, ok := i.(Vertex)
         des(t2) // main.Vertex, {0, 0}
         chk(t2, ok)
       }

       func des(v interface{}) {
         fmt.Printf("%T, %v\n", v, v)
       }

       func chk(t interface{}, ok bool) {
         if !ok {
           fmt.Println("type not correct, zero value returned:", t)
         } else {
           fmt.Println("type correct, value is:", t)
         }
       }
     #+end_src

**** type switches

     #+begin_src go
       package main

       import "fmt"

       func do(i interface{}) {
         switch v := i.(type) {
         case int:
           fmt.Printf("Twice %v is %v\n", v, v*2)
         case string:
           fmt.Printf("%q is %v bytes long\n", v, len(v))
         default:
           // here v has the same type as i
           fmt.Printf("I don't know about type %T!\n", v)
         }
       }

       func main() {
         do(21)
         do("hello")
         do(true)
       }
     #+end_src

** Zero values

   variables declared without an explicit initial value are given their zero
   value.

   + 0 for numeric types
   + false for the boolean type
   + "" (the empty string) for the strings
   + ~{<default field values>}~ for structs
   + nil for slice (len and cap of a nil slice is 0)
   + nil for maps
   + nil for interfaces
   + nil for pointers

** Common Interfaces

*** Error

    When ~fmt~ prints values, it looks for the error interface first:

    #+begin_src go
      type error interface {
        Error() string
      }
    #+end_src

    if the interface value is not ~<nil>~, the Error() method will be invoked by
    ~fmt~ to get the error string.

    #+begin_src go
      i, err := strconv.Atoi("42")
      if err != nil {
        fmt.Printf("couldn't convert number: %v\n", err)
        return
      }
      fmt.Println("Converted integer:", i)
    #+end_src

    Do not print the interface value in the Error() method directly, it will cause
    infinite loop.

    #+begin_src go
      type ErrNegativeSqrt float64

      func (e ErrNegativeSqrt) Error() string {
        // do not print e directly, infinite loop here
        // fmt.Println(e)
        return fmt.Sprintln("cannot Sqrt negative number: ", float64(e))
      }
    #+end_src

*** Reader

    the ~io.Reader~ interface has a ~Read~ method:

    #+begin_src go
      func (T) Read(b []byte) (n int, err error)
    #+end_src

    read populates the given byte slice with data and returns the number of bytes
    populated and an error value.

    it returns an ~io.EOF~ error when the stream ends.

    #+begin_src go
      package main

      import (
        "fmt"
        "io"
        "strings"
      )

      func main() {
        r := strings.NewReader("Hello, Reader!")

        b := make([]byte, 8)
        for {
          n, err := r.Read(b)
          fmt.Printf("n = %v err = %v b = %v\n", n, err, b)
          fmt.Printf("b[:n] = %q\n", b[:n])
          if err == io.EOF {
            break
          }
        }
      }
    #+end_src

*** Image

    ~image.Image~ defines the Image interface

    #+begin_src go
      type Image interface {
        ColorModel() color.Model
        Bounds() Rectangle
        At(x, y int) color.Color
      }
    #+end_src

** Goroutines

   a /goroutine/ is a lightweight thread managed by the Go runtime.

*** Channels

    By default, sends and receives block until the other side is ready. This
    allows goroutines to synchronize without explicit locks or condition
    variables.

    Channels aren't like files, you don't usually need to close them. Closing is
    only necessary when the receiver must be told there are no more values
    coming, such as to terminate a ~range~ loop.

    #+begin_src go
      package main

      import "fmt"

      func fib(n int, c chan int) {
        a, b := 0, 1
        for i := 0; i < n; i++ {
          c <- a
          a, b = b, a+b
        }
        close(c)
      }

      func main() {
        c := make(chan int)
        go fib(10, c)
        for x := range c {
          fmt.Println(x)
        }
        // "ok" is false if there are:
        // 1. no more values to receive
        // 2. and the channel is closed
        // x, ok := <- c
      }
    #+end_src

*** Select

    /select/ statement lets a goroutine wait on multiple communication
    operations.

    /select/ blocks until one of its cases can run (by adding a /default/ case,
    it won't block). It chooses one at random if multiple are ready.

    #+begin_src go
      package main

      import "fmt"

      func fibonacci(c, quit chan int) {
        x, y := 0, 1
        for {
          select {
          case c <- x:
            x, y = y, x+y
          case <-quit:
            fmt.Println("quit")
            return
          }
        }
      }

      func main() {
        c := make(chan int)
        quit := make(chan int)
        go func() {
          for i := 0; i < 10; i++ {
            fmt.Println(<-c)
          }
          quit <- 0
        }()
        fibonacci(c, quit)
      }
    #+end_src

*** Mutex

    /sync.Mutex/ provides two methods: ~Lock~ and ~Unlock~

    #+begin_src go
      // SafeCounter is safe to use concurrently.
      type SafeCounter struct {
        mu sync.Mutex
        v  map[string]int
      }

      func (c *SafeCounter) Value(key string) int {
        c.mu.Lock()
        // Lock so only one goroutine at a time can access the map c.v.
        defer c.mu.Unlock()
        return c.v[key]
      }
    #+end_src

** Practice

*** Sqrt

    #+begin_src go
      package main

      import "fmt"

      func Sqrt(x float64) (res float64) {
        res = 1.
        diff := 1.
        for diff > 1e-5 || diff < -1e-5 {
          diff = (res*res - x) / (2 * res)
          res -= diff
        }
        return
      }

      func main() {
        fmt.Println(Sqrt(4))
      }
    #+end_src

*** WordCount

    #+begin_src go
      package main

      import (
        "strings"

        "golang.org/x/tour/wc"
      )

      func WordCount(s string) (m map[string]int) {
        m = make(map[string]int)
        for _, x := range strings.Fields(s) {
          m[x]++
        }
        return m
      }

      func main() {
        wc.Test(WordCount)
      }
    #+end_src

*** Fibonacci closure

    #+begin_src go
      package main

      import "fmt"

      // fibonacci is a function that returns
      // a function that returns an int.
      func fibonacci() func() int {
        a, b := 0, 1
        return func() int {
          ret := a
          a, b = b, a + b
          return ret
        }
      }

      func main() {
        f := fibonacci()
        for i := 0; i < 10; i++ {
          fmt.Println(f())
        }
      }
    #+end_src

*** Sqrt with Error Handling

    #+begin_src go
      package main

      import (
        "fmt"
        "math"
      )

      type ErrNegativeSqrt float64

      func (e ErrNegativeSqrt) Error() string {
        // float64(e) here is important
        // fmt.Sprint(e) will cause infinite loop!
        return fmt.Sprint("cannot Sqrt negative number:", float64(e))
      }

      func Sqrt(x float64) (float64, error) {
        if x < 0 {
          return x, ErrNegativeSqrt(x)
        }
        return math.Sqrt(x), nil
      }

      func main() {
        fmt.Println(Sqrt(2))
        fmt.Println(Sqrt(-2))
      }
    #+end_src

*** rot13Reader

    #+begin_src go
      package main

      import (
        "io"
        "os"
        "strings"
      )

      type rot13Reader struct {
        r io.Reader
      }

      func (rot13reader rot13Reader) Read(b []byte) (int, error) {
        n, err := rot13reader.r.Read(b)
        if err != nil {
          return 0, io.EOF
        }
        for i := 0; i < n; i++ {
          switch c := b[i]; {
          case c >= 'A' && c <= 'Z':
            b[i] = 'A' + (b[i]-'A'+13)%26
          case c >= 'a' && c <= 'z':
            b[i] = 'a' + (b[i]-'a'+13)%26
          }
        }
        return n, nil
      }

      func main() {
        s := strings.NewReader("Lbh penpxrq gur pbqr!")
        r := rot13Reader{s}
        io.Copy(os.Stdout, &r)
      }
    #+end_src

*** Implement Image interface

    #+begin_src go
      package main

      import (
        "image"
        "image/color"

        "golang.org/x/tour/pic"
      )

      type Image struct {
        w, h int
      }

      func (img Image) ColorModel() color.Model {
        return color.RGBAModel
      }

      func (img Image) Bounds() image.Rectangle {
        return image.Rect(0, 0, img.w, img.h)
      }

      func (img Image) At(x, y int) color.Color {
        return color.RGBA{uint8(x + y), uint8(x + y), 255, 255}
      }

      func main() {
        m := Image{100, 100}
        pic.ShowImage(m)
      }
    #+end_src

*** Web Crawler

    #+begin_src go
      package main

      import (
        "fmt"
        "sync"
      )

      type Fetcher interface {
        // Fetch returns the body of URL and
        // a slice of URLs found on that page.
        Fetch(url string) (body string, urls []string, err error)
      }

      type url2Dep struct {
        mu sync.Mutex
        mp map[string]int
      }

      func (u *url2Dep) insertUrl(url string, dep int) {
        u.mu.Lock()
        defer u.mu.Unlock()
        u.mp[url] = dep
      }

      func (u *url2Dep) getDep(url string) (int, bool) {
        u.mu.Lock()
        defer u.mu.Unlock()
        dep, ok := u.mp[url]
        return dep, ok
      }

      // Crawl uses fetcher to recursively crawl
      // pages starting with url, to a maximum of depth.
      func Crawl(u *url2Dep, url string, depth int, fetcher Fetcher) {
        defer wg.Done()
        if depth <= 0 {
          return
        }
        if dep, ok := u.getDep(url); !ok || dep < depth {
          u.insertUrl(url, depth)
        } else {
          fmt.Printf("visited: %s\n", url)
          return
        }
        body, urls, err := fetcher.Fetch(url)
        if err != nil {
          fmt.Println(err)
          return
        }
        fmt.Printf("found: %s %q\n", url, body)
        for _, nextUrl := range urls {
          wg.Add(1)
          go Crawl(u, nextUrl, depth-1, fetcher)
        }
      }

      var wg sync.WaitGroup

      func main() {
        u := url2Dep{mp: make(map[string]int)}
        wg.Add(1)
        go Crawl(&u, "https://golang.org/", 4, fetcher)
        wg.Wait()
      }

      // fakeFetcher is Fetcher that returns canned results.
      type fakeFetcher map[string]*fakeResult

      type fakeResult struct {
        body string
        urls []string
      }

      func (f fakeFetcher) Fetch(url string) (string, []string, error) {
        if res, ok := f[url]; ok {
          return res.body, res.urls, nil
        }
        return "", nil, fmt.Errorf("not found: %s", url)
      }

      // fetcher is a populated fakeFetcher.
      var fetcher = fakeFetcher{
        "https://golang.org/": &fakeResult{
          "The Go Programming Language",
          []string{
            "https://golang.org/pkg/",
            "https://golang.org/cmd/",
          },
        },
        "https://golang.org/pkg/": &fakeResult{
          "Packages",
          []string{
            "https://golang.org/",
            "https://golang.org/cmd/",
            "https://golang.org/pkg/fmt/",
            "https://golang.org/pkg/os/",
          },
        },
        "https://golang.org/pkg/fmt/": &fakeResult{
          "Package fmt",
          []string{
            "https://golang.org/",
            "https://golang.org/pkg/",
          },
        },
        "https://golang.org/pkg/os/": &fakeResult{
          "Package os",
          []string{
            "https://golang.org/",
            "https://golang.org/pkg/",
          },
        },
      }
    #+end_src
* DONE Vim Notes                                          :@notes:vim:editor:
  CLOSED: [2021-12-06 Mon 20:56]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: vim-notes
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2021-12-06 Mon 20:24]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/vim-logo.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "my notes/cheatsheet on using vim."
:END:

** my simple config

my simple config can be found here: [[https://github.com/sky-bro/.dotfiles/blob/master/.vimrc][.dotfiles/.vimrc]]

** widows

+ /*C-w s*/ :: horizontal split window
+ /*C-w v*/ :: vertical split window
+ /*C-w q*/ :: quit a window
+ /*C-w h/j/k/l*/ :: move between windows
+ /*C-w H/J/K/L*/ :: make current master window
+ /*C-w +\slash-*/ :: inc/dec height, can prepend with a number
+ /*C-w >/<*/ :: inc/dec width, can prepend with a number

** jump

+ /*C-o*/ :: jump back
+ /*C-i*/ :: jump forward

** References

+ [[https://vim.rtorr.com/][Vim Cheat Sheet]]
+ [[../static/images/posts/vim-notes/vim-cheatsheet.svg][vi / vim graphical cheat sheet]]
* TODO Shows & Movies                           :@entertainment:movies:shows:
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: shows-and-movies
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2021-12-07 Tue 18:53]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/movie.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "shows & and movies that I love."
:END:

旺角卡门
国产玲玲发

Men of Honor 怒海潜将

* DONE Ranger Notes                                           :@notes:ranger:
  CLOSED: [2021-12-08 Wed 00:03]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: ranger-notes
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2021-12-07 Tue 19:16]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/ranger_logo.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "ranger is a terminal based file manager."
:END:

I am planing on totally changing to the terminal based file manager: ranger.

And this is my cheatsheet on using it, for more detailed guides you can go check the ranger official user guide[fn:ranger-official-user-guide].

** launch

I use ~$mod+Shift+Return~ to launch my ranger, and this keybinding is set in the i3 config file as below.

#+begin_src shell
  # ~/.config/i3/config
  bindsym $mod+Shift+Return exec cd "$(xcwd)" && exec st -e "ranger"
#+end_src

Here I also use xcwd[fn:xcwd] to get my current working directory, so I can launch ranger from that directory.

** Key bindings and hints

+ ~g~: navigation and tabs
+ ~r~: open with
+ ~y~: yank
+ ~d~: cut/delete
+ ~p~: paste
+ ~o~: sort
+ ~.~: filter_stack ??
+ ~z~: settings
+ ~u~: undo
+ ~M~: linemode
+ ~+, -, =~: rights
+ ~Alt+N~: switch(~Tab~), create tab

** configuration files

under =~/.config/ranger/= folder, there are 4 main configuration files:

+ ~rc.conf~: the main config, various key bindings and switches
+ ~rfile.conf~: how to open a file
+ ~scope.sh~: how to preview a file
+ ~commands.py~: implement various commands (functions), you can add your custom commands here.

** Bookmarks

+ ~m<key>~: bookmark current folder
+ ~'<key>~: go to a bookmark
+ ~um<key>~: remove a bookmark

** Select/Mark files

+ ~SPC~: mark current file
+ ~v~: invert selection (easy to select all)
+ ~V~: visual mode, to mark a range of files
+ ~:mark REGEX~, ~:unmark REGEX~: to mark/unmark with regex expression.
+ ~uv~, ~:unmark~: unmark all files

** Macros

+ ~%f~: the highlighted file
+ ~%d~: the path of the current directory
+ ~%s~: the selected files in the current directory
+ ~%t~: the tagged files in the current directory
+ ~%c~: the full pathes of the currently copied/cut files
+ ~%p~: the full pathes of selected files

** Rename, Create Files & Folders

+ ~cw~: to rename selected file or files (bulk rename, works great with ~:flat~)
+ ~:mkdir~: create directory
+ ~:touch~: create file

* DONE Terminal & Shell Setup (st & zsh)              :@notes:shell:terminal:
  CLOSED: [2021-12-09 Thu 00:09]
:PROPERTIES:
:EXPORT_HUGO_BUNDLE: terminal-and-shell-setup--st-and-zsh
:EXPORT_FILE_NAME: index
:EXPORT_DATE: [2021-12-08 Wed 17:07]
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :image "/images/icons/terminal.png"
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :libraries '(mathjax)
:EXPORT_HUGO_CUSTOM_FRONT_MATTER+: :description "show my terminal & shell setup."
:END:

My terminal emulator is st (simple terminal) from LukeSmith[fn:st-from-luke], and my shell is zsh (with ohmyzsh[fn:ohmyzsh]).

** Dependencies

+ dmenu
+ fzf[fn:fzf]
+ pywal[fn:pywal]

** ohmyzsh

#+begin_src shell
  # . start-proxy 1081 socks5h
  sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
#+end_src

Then config or restore[fn:dotfiles] your ~~/.zshrc~ file.

#+begin_src shell
  dotfiles checkout ~/.zshrc
#+end_src

** colors and themes

*** p10k

I use powerlevel10k[fn:p10k] as my zsh theme.

1. clone the repository:
   #+begin_src shell
     git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k
     # for chinese users, recommend:
     # git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k
   #+end_src
2. set ~ZSH_THEME="powerlevel10k/powerlevel10k"~ in ~~/.zshrc~.
3. configure with ~p10k~

*** Xresources and pywal

you can define your color scheme in ~~/.Xresources~ file, and load it with ~xrdb ~/.Xresources~.

Or you can let pywal generates and sets a colorscheme for you:

#+begin_src shell
  #!/bin/sh

  # We grab the wallpaper location from wal's cache so
  # that this works even when a directory is passed.
  image_path="${1:-"$(< "${HOME}/.cache/wal/wal")"}"

  # -n tells `wal` to skip setting the wallpaper.
  wal -n -i "$image_path"
  feh --no-fehbg --bg-fill "$image_path"
#+end_src

This is a script[fn:wal-feh] to set my wallpaper and color scheme from an image: ~wal-feh wallpaper.png~.

And I put ~exec --no-startup-id ~/bin/wal-feh~ in my ~~/.config/i3/config~ to autostart it.

** fzf

Install fzf, then put this in your ~~/.zshrc~:

#+begin_src shell
  source /usr/share/fzf/key-bindings.zsh
  source /usr/share/fzf/completion.zsh
#+end_src

** zsh-autosuggestions

Fish-like fast/unobtrusive autosuggestions for zsh.

1. clone the repository:

   #+begin_src shell
     git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
   #+end_src

2. add the plugin to the ~plugins~ list inside the ~~/.zshrc~ file.

   #+begin_src shell
     plugins=(
         # other plugins...
         zsh-autosuggestions
     )
   #+end_src

** keybindings

+ ~alt-l~: follow urls
+ ~alt-y~: copy urls
+ ~alt-o~: copy output of a command
+ ~alt-j/k/d/u~: scroll down/up/faster-down/faster-up
+ ~alt-c/v~: copy/paste
+ ~Ctrl+t~: list files+folders in current directory (e.g., type ~git add~, press ~Ctrl+t~, select a few files using ~Tab~, finally ~Enter~)
+ ~Ctrl+r~: search history commands
+ ~ESC+c~: fuzzy change directory

* Footnotes

[fn:orgmode] [[https://orgmode.org/][org mode official site]]

[fn:seed-random-generator] [[https://emacs.stackexchange.com/questions/58285/orgmode-latex-export-how-to-create-repeatable-labels][org export: create repeatable labels]]

[fn:org-export-new-reference] [[https://www.reddit.com/r/orgmode/comments/aagmfh/export_to_html_with_useful_nonrandom_ids_and/][Export to HTML with useful, non-random IDs and anchors]]

[fn:ranger-official-user-guide] [[https://github.com/ranger/ranger/wiki/Official-User-Guide][ranger official user guide]]

[fn:xcwd] [[https://github.com/schischi/xcwd][xcwd]] is a simple tool that prints the current working directory of the currently focused window.

[fn:st-from-luke] [[https://github.com/LukeSmithxyz/st][st]] from Luke Smith

[fn:ohmyzsh] [[https://ohmyz.sh/][Oh My Zsh]] is a delightful, open source, community-driven framework for managing your Zsh configuration

[fn:fzf] [[https://github.com/junegunn/fzf][fzf]] is a general-purpose command-line fuzzy finder

[fn:pywal] [[https://github.com/dylanaraps/pywal][Pywal]] is a tool that generates a color palette from the dominant colors in an image.

[fn:dotfiles] use a bare git repository to manage [[https://github.com/sky-bro/.dotfiles][dotfiles]].

[fn:p10k] [[https://github.com/romkatv/powerlevel10k][Powerlevel10k]] is a theme for Zsh. It emphasizes speed, flexibility and out-of-the-box experience.

[fn:wal-feh] my [[https://github.com/sky-bro/.dotfiles/blob/master/bin/wal-feh][wal-feh]] script to set wallpaper and color scheme
